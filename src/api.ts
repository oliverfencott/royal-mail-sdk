/* tslint:disable */
/* eslint-disable */
/**
 * Royal Mail API Shipping V3 (REST)
 * This API specification details the requirements for integrating with **Royal Mail API Shipping V3**.<br><br>It specifically covers how the Royal Mail API Shipping V3 can be used by business customers to conduct shipping activity with Royal Mail and provides the technical information to build this integration. This specification must be used with the relevant accompanying specifications for customers wishing to interface their systems with Royal Mail services.<br><br>Royal Mail API Shipping V3 exposes a fully RESTful service that allows account customers to create shipments, produce labels, and produce documentation for all the tasks required to ship domestic items with Royal Mail.<br><br>Built on industry standards, Royal Mail API Shipping V3 provides a simple and low cost method for customers to integrate with Royal Mail, and allows them to get shipping quickly. The API offers data streaming and offline barcoding to allow customers greater flexibility when generating their labels. There are no costs to customers for using the Royal Mail API Shipping V3 services, however customers’ own development costs must be covered by the customer developing the solution. Royal Mail will not accept any responsibility for these development, implementation and testing costs. Customers should address initial enquiries regarding development of systems for these purposes to their account handler.<br><br>This API can be used in conjunction with Royal Mail Pro Shipping, a GUI based shipping platform. For more details on Royal Mail Pro Shipping, including videos on and briefs on updating/ cancelling a shipment and Manifesting please refer to http://www.royalmail.com/pro-shipping-help.
 *
 * The version of the OpenAPI document: 3.0.15
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * An address that is part of the address book.<br />A stored address can be used in shipment requests.
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * Address ID<br />Your unique identifier for this address.<br />If not provided, a GUID will be generated.
     * @type {string}
     * @memberof Address
     */
    AddressId?: string;
    /**
     * Is Return Address<br />If true, then this address is also available as a return address.
     * @type {boolean}
     * @memberof Address
     */
    IsReturnAddress: boolean;
    /**
     * Company Name<br />*Ignored if is a return address*
     * @type {string}
     * @memberof Address
     */
    CompanyName?: string;
    /**
     * Contact Name / Return Name
     * @type {string}
     * @memberof Address
     */
    ContactName: string;
    /**
     * Address Line 1
     * @type {string}
     * @memberof Address
     */
    AddressLine1: string;
    /**
     * Address Line 2
     * @type {string}
     * @memberof Address
     */
    AddressLine2?: string;
    /**
     * Address Line 3
     * @type {string}
     * @memberof Address
     */
    AddressLine3?: string;
    /**
     * Town
     * @type {string}
     * @memberof Address
     */
    Town: string;
    /**
     * County / State / Province<br />Conditional dependent on country.<br />USA, Australia and Canada all require a valid state code or name.
     * @type {string}
     * @memberof Address
     */
    County?: string;
    /**
     * Country Code<br />[ISO Alpha-2 Country Code](https://www.nationsonline.org/oneworld/country_code_list.htm) per ISO 3166 Standard<br />*Required to be GB if is a return address*
     * @type {string}
     * @memberof Address
     */
    CountryCode: string;
    /**
     * Postcode / Zip<br />Required for domestic addresses and some international addresses.
     * @type {string}
     * @memberof Address
     */
    Postcode?: string;
    /**
     * Contact Phone Number<br />Required for destination addresses where SMS notifications are requested.<br />(Service Enhancement Code 13 or 16)<br />*Ignored if is a return address*
     * @type {string}
     * @memberof Address
     */
    PhoneNumber?: string;
    /**
     * Contact Email Address<br />Required for destination addresses where email notifications are requested.<br />(Service Enhancement Code 14 or 16)<br />*Ignored if is a Return Address*
     * @type {string}
     * @memberof Address
     */
    EmailAddress?: string;
    /**
     * VAT Number<br />*Ignored if is a return address*
     * @type {string}
     * @memberof Address
     */
    VatNumber?: string;
    /**
     * Safeplace<br />Free text to describe a safe place to leave the parcel if the service allows it.<br />*Ignored if is a return address*
     * @type {string}
     * @memberof Address
     */
    Safeplace?: string;
}
/**
 * Response from a create / update or delete address request.
 * @export
 * @interface AddressResponse
 */
export interface AddressResponse {
    /**
     * Address Id<br />The Id of the Address involved in the request, or in the case of create, the created Id, if not provided.
     * @type {string}
     * @memberof AddressResponse
     */
    AddressId?: string;
    /**
     * HTTP Status Code
     * @type {number}
     * @memberof AddressResponse
     */
    HttpStatusCode: number;
    /**
     * HTTP Status Description
     * @type {string}
     * @memberof AddressResponse
     */
    HttpStatusDescription: string;
    /**
     * Message<br />Successful response may include a success message.<br />Failure responses will have general reason as to why. Further details may be contained in the list of errors.
     * @type {string}
     * @memberof AddressResponse
     */
    Message?: string;
    /**
     * Errors<br />Details about why a request failed.
     * @type {Array<ErrorDetail>}
     * @memberof AddressResponse
     */
    Errors?: Array<ErrorDetail>;
}
/**
 * The destination address and contact details.<br />It is the shipper’s responsibility to provide accurate and concise information to ensure the best possible delivery experience for the consumer.
 * @export
 * @interface CreateShipmentDestination
 */
export interface CreateShipmentDestination {
    /**
     * Destination Address ID<br />If supplied all destination address fields will be ignored and the stored address will be used.<br />*If a Safeplace is present in the stored address, the Safeplace enhancement will be used if the service allows it, otherwise it will be ignored. ShipmentInformation.ServiceOptions.Safeplace overrides the address Safeplace and forces Safeplace to be required enhancement of the service.*
     * @type {string}
     * @memberof CreateShipmentDestination
     */
    AddressId?: string;
    /**
     * Company Name
     * @type {string}
     * @memberof CreateShipmentDestination
     */
    CompanyName?: string;
    /**
     * Contact Name<br />Required if Address Id is not provided.
     * @type {string}
     * @memberof CreateShipmentDestination
     */
    ContactName?: string;
    /**
     * Address Line 1<br />Required if Address Id is not provided.
     * @type {string}
     * @memberof CreateShipmentDestination
     */
    AddressLine1?: string;
    /**
     * Address Line 2<br />*Please ensure the address data is presented in line with the destination country formats.*
     * @type {string}
     * @memberof CreateShipmentDestination
     */
    AddressLine2?: string;
    /**
     * Address Line 3<br />*Please ensure the address data is presented in line with the destination country formats.*
     * @type {string}
     * @memberof CreateShipmentDestination
     */
    AddressLine3?: string;
    /**
     * Town<br />Required if Address Id is not provided.
     * @type {string}
     * @memberof CreateShipmentDestination
     */
    Town?: string;
    /**
     * County / State / Province<br />Whether this is required or not is dependent on the country settings.
     * @type {string}
     * @memberof CreateShipmentDestination
     */
    County?: string;
    /**
     * Country Code<br />[ISO Alpha-2 Country Code](https://www.nationsonline.org/oneworld/country_code_list.htm)  per ISO 3166 Standard.  Required if Address Id is not provided
     * @type {string}
     * @memberof CreateShipmentDestination
     */
    CountryCode?: string;
    /**
     * Postcode / Zip<br />Mandatory for all domestic shipments and some international shipments if the Address Id is not provided.
     * @type {string}
     * @memberof CreateShipmentDestination
     */
    Postcode?: string;
    /**
     * Contact Phone Number<br />Required if SMS notifications are requested (Service Enhancement Code 13 or 16) and Address Id is not provided.<br />Must be a valid phone number.
     * @type {string}
     * @memberof CreateShipmentDestination
     */
    PhoneNumber?: string;
    /**
     * Contact Email Address<br />Required if email notifications are requested (Service Enhancement Code 14 or 16) and Address Id is not provided.<br />Must be a valid email address.
     * @type {string}
     * @memberof CreateShipmentDestination
     */
    EmailAddress?: string;
    /**
     * VAT Number
     * @type {string}
     * @memberof CreateShipmentDestination
     */
    VatNumber?: string;
}
/**
 * The Service Options for a Royal Mail Shipment, used in a shipment request.<br />Required if have more than 1 possible Posting Location.
 * @export
 * @interface CreateShipmentServiceOptions
 */
export interface CreateShipmentServiceOptions {
    /**
     * Posting Location.<br />Optional if you only have 1 Posting Location.
     * @type {string}
     * @memberof CreateShipmentServiceOptions
     */
    PostingLocation: string;
    /**
     * Service Level<br />Valid values are 01-99.<br />Defaults to lowest service level if not provided.
     * @type {string}
     * @memberof CreateShipmentServiceOptions
     */
    ServiceLevel?: string;
    /**
     * Service Format<br />            <br />**L** - Letter<br />**F** - Large Letter<br />**P** - Parcel<br />**S** - Printed Papers - International Services Only
     * @type {string}
     * @memberof CreateShipmentServiceOptions
     */
    ServiceFormat?: CreateShipmentServiceOptionsServiceFormatEnum;
    /**
     * Safe Place Enhancement<br />Free text to describe a safe place to leave the parcel.<br />Returns an error if the service does not allow Safeplace.
     * @type {string}
     * @memberof CreateShipmentServiceOptions
     */
    Safeplace?: string;
    /**
     * Saturday Guaranteed Enhancement<br />Available for Domestic Special Delivery Services Only<br />Returns an error if requested and the service does not allow it.
     * @type {boolean}
     * @memberof CreateShipmentServiceOptions
     */
    SaturdayGuaranteed?: boolean;
    /**
     * Consequential Loss Enhancement<br />Available for Domestic Special Delivery Services Only.<br />            <br />**Level1** - £1,000<br />**Level2** - £2,500<br />**Level3** - £5,000<br />**Level4** - £7,500<br />**Level5** - £10,000<br />            <br />Returns an error if requested and the service does not allow it.
     * @type {string}
     * @memberof CreateShipmentServiceOptions
     */
    ConsequentialLoss?: CreateShipmentServiceOptionsConsequentialLossEnum;
    /**
     * Local Collect Enhancement<br />Available for Domestic Special Delivery and Domestic Tracked services only.<br />Returns an error if requested and the service does not allow it.
     * @type {boolean}
     * @memberof CreateShipmentServiceOptions
     */
    LocalCollect?: boolean;
    /**
     * Tracking Notifications Enhancement<br />Available for Domestic Special Delivery and Domestic Tracked services only.<br />Returns an error if requested and the service does not allow it.
     * @type {string}
     * @memberof CreateShipmentServiceOptions
     */
    TrackingNotifications?: CreateShipmentServiceOptionsTrackingNotificationsEnum;
    /**
     * Recorded Signed For<br />Available for all Domestic Services that are not Special Delivery, Tracked or BFPO.<br />This is an enhancement for services that don\'t have an in-built signature service like Special Delivery and Tracked.<br />Returns an error if requested and the service does not allow it.
     * @type {boolean}
     * @memberof CreateShipmentServiceOptions
     */
    RecordedSignedFor?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum CreateShipmentServiceOptionsServiceFormatEnum {
    L = 'L',
    F = 'F',
    P = 'P',
    S = 'S'
}
/**
    * @export
    * @enum {string}
    */
export enum CreateShipmentServiceOptionsConsequentialLossEnum {
    Level1 = 'Level1',
    Level2 = 'Level2',
    Level3 = 'Level3',
    Level4 = 'Level4',
    Level5 = 'Level5'
}
/**
    * @export
    * @enum {string}
    */
export enum CreateShipmentServiceOptionsTrackingNotificationsEnum {
    Email = 'Email',
    SMS = 'SMS',
    EmailAndSMS = 'EmailAndSMS'
}

/**
 * Details of a shipment request.
 * @export
 * @interface CreateShipmentShipment
 */
export interface CreateShipmentShipment {
    /**
     * 
     * @type {Shipper}
     * @memberof CreateShipmentShipment
     */
    Shipper?: Shipper;
    /**
     * 
     * @type {CreateShipmentDestination}
     * @memberof CreateShipmentShipment
     */
    Destination: CreateShipmentDestination;
    /**
     * 
     * @type {CreateShipmentShipmentInformation}
     * @memberof CreateShipmentShipment
     */
    ShipmentInformation: CreateShipmentShipmentInformation;
}
/**
 * Shipment Information. Overall package details, item details and requested service information in a shipment request.<br /> It is important to ensure accurate information is supplied to ensure correct handling by different customs around the world.
 * @export
 * @interface CreateShipmentShipmentInformation
 */
export interface CreateShipmentShipmentInformation {
    /**
     * Shipment Date<br />Date of despatch - YYYY-MM-DD.<br />Cannot be in the past. Max 28 days in the future.
     * @type {string}
     * @memberof CreateShipmentShipmentInformation
     */
    ShipmentDate: string;
    /**
     * Service Code<br />Must be a valid system service code OR a customer mapped service code.
     * @type {string}
     * @memberof CreateShipmentShipmentInformation
     */
    ServiceCode: string;
    /**
     * 
     * @type {CreateShipmentServiceOptions}
     * @memberof CreateShipmentShipmentInformation
     */
    ServiceOptions?: CreateShipmentServiceOptions;
    /**
     * Number of Packages<br />The total number of packages.
     * @type {number}
     * @memberof CreateShipmentShipmentInformation
     */
    TotalPackages: number;
    /**
     * Total Weight<br />The total weight of the shipment including packaging. Validated againt package weight.<br />Min weight: 1 gram.     <br />*Optional/Overwritten for Average Weight Services - Average Weight Customers only.*
     * @type {number}
     * @memberof CreateShipmentShipmentInformation
     */
    TotalWeight: number;
    /**
     * Weight Unit of Measure
     * @type {string}
     * @memberof CreateShipmentShipmentInformation
     */
    WeightUnitOfMeasure?: CreateShipmentShipmentInformationWeightUnitOfMeasureEnum;
    /**
     * Shipment/Product type being shipped<br />            <br />**DOX** - Documents Only<br />**NDX** - All other shipment product types
     * @type {string}
     * @memberof CreateShipmentShipmentInformation
     */
    Product?: CreateShipmentShipmentInformationProductEnum;
    /**
     * Description of Goods<br />General description of the goods being sent.<br />Required for Non-Document International and BFPO Shipments.<br />Ignored for Documents Only shipments.
     * @type {string}
     * @memberof CreateShipmentShipmentInformation
     */
    DescriptionOfGoods?: string;
    /**
     * Reason For Export<br />Required for International Shipments and BFPO (British Forces Post Office).
     * @type {string}
     * @memberof CreateShipmentShipmentInformation
     */
    ReasonForExport?: string;
    /**
     * Total Shipment Value<br />Required for Non-Document International and BFPO Shipments.<br />Ignored for Documents Only shipments.
     * @type {number}
     * @memberof CreateShipmentShipmentInformation
     */
    Value?: number;
    /**
     * Currency<br />This currency will be used for all values across the shipment request.<br />3 digit ISO Currency Code.<br />Required for Non-Document International and BFPO Shipments, or when values are provided.<br />Ignored for Documents Only shipments.
     * @type {string}
     * @memberof CreateShipmentShipmentInformation
     */
    Currency?: string;
    /**
     * Requested Label Format<br />*DATASTREAM is only available if it has been activated on your account.*<br />Ignored if ShipmentAction set to Create or Allocate.
     * @type {string}
     * @memberof CreateShipmentShipmentInformation
     */
    LabelFormat?: CreateShipmentShipmentInformationLabelFormatEnum;
    /**
     * Silent Print Profile<br />If present, resulting labels will be printed using this profile.
     * @type {string}
     * @memberof CreateShipmentShipmentInformation
     */
    SilentPrintProfile?: string;
    /**
     * Shipment Action<br />            <br />**Process** - Shipment created and processed, ready for manifesting. Label and tracking number returned.<br />            <br />**Create** - Shipment created as unprocessed, ready for scanning. Scanning will create label and tracking number and move shipment to processed.<br />            <br />**Allocate** - Shipment created as unprocessed with tracking number allocated and returned and label created but not returned. Scanning will return label and move shipment to processed.
     * @type {string}
     * @memberof CreateShipmentShipmentInformation
     */
    ShipmentAction?: CreateShipmentShipmentInformationShipmentActionEnum;
    /**
     * Shipment Packages<br />The packages in the shipment.<br />Required if TotalPackages is more than 1.
     * @type {Array<CreateShipmentShipmentPackage>}
     * @memberof CreateShipmentShipmentInformation
     */
    Packages?: Array<CreateShipmentShipmentPackage>;
    /**
     * Shipment Items<br />The items in the shipment.<br />Required for Non-Document International Shipments and BFPO (British Forces Post Office).<br />Ignored for Documents Only shipments.
     * @type {Array<ShipmentItem>}
     * @memberof CreateShipmentShipmentInformation
     */
    Items?: Array<ShipmentItem>;
}

/**
    * @export
    * @enum {string}
    */
export enum CreateShipmentShipmentInformationWeightUnitOfMeasureEnum {
    KG = 'KG',
    Grams = 'Grams'
}
/**
    * @export
    * @enum {string}
    */
export enum CreateShipmentShipmentInformationProductEnum {
    NDX = 'NDX',
    DOX = 'DOX'
}
/**
    * @export
    * @enum {string}
    */
export enum CreateShipmentShipmentInformationLabelFormatEnum {
    PDF = 'PDF',
    PNG = 'PNG',
    DATASTREAM = 'DATASTREAM',
    ZPL203DPI = 'ZPL203DPI',
    ZPL300DPI = 'ZPL300DPI'
}
/**
    * @export
    * @enum {string}
    */
export enum CreateShipmentShipmentInformationShipmentActionEnum {
    Process = 'Process',
    Allocate = 'Allocate',
    Create = 'Create'
}

/**
 * Details of a package in a shipment request.<br />Enter the dimensions and weight of the package in the shipment. Use the PackageOccurance to indicate the items within the package.
 * @export
 * @interface CreateShipmentShipmentPackage
 */
export interface CreateShipmentShipmentPackage {
    /**
     * Package Occurrence<br />Unique package number within this shipment.<br />Cannot exceed total number of packages.
     * @type {number}
     * @memberof CreateShipmentShipmentPackage
     */
    PackageOccurrence: number;
    /**
     * Packaging ID<br />If supplied, packaging details will be populated from the stored information.
     * @type {string}
     * @memberof CreateShipmentShipmentPackage
     */
    PackagingId?: string;
    /**
     * Total Package Weight.<br />            <br />This field will be used as the Shipment Weight for single-package services such as RMG.<br />The package weight must be greater than or equal to the sum of all item weights and packaging, if this information is provided.<br />Min weight: 1 gram.<br />*Optional/Overwritten for Average Weight Services - Average Weight Customers only.*
     * @type {number}
     * @memberof CreateShipmentShipmentPackage
     */
    Weight: number;
    /**
     * Package Length<br />Dimensions are in Centimetres.<br />*Dimensions are optional, however supplying accurate information helps ensure a smooth delivery experience.*
     * @type {number}
     * @memberof CreateShipmentShipmentPackage
     */
    Length?: number;
    /**
     * Package Width<br />Dimensions are in Centimetres.<br />*Dimensions are optional, however supplying accurate information helps ensure a smooth delivery experience.*
     * @type {number}
     * @memberof CreateShipmentShipmentPackage
     */
    Width?: number;
    /**
     * Package Height<br />Dimensions are in Centimetres.<br />*Dimensions are optional, however supplying accurate information helps ensure a smooth delivery experience.*
     * @type {number}
     * @memberof CreateShipmentShipmentPackage
     */
    Height?: number;
}
/**
 * Details about an error
 * @export
 * @interface ErrorDetail
 */
export interface ErrorDetail {
    /**
     * Message<br />The error message, or issue.
     * @type {string}
     * @memberof ErrorDetail
     */
    Message?: string;
    /**
     * Cause<br />The cause of the error.
     * @type {string}
     * @memberof ErrorDetail
     */
    Cause?: string;
    /**
     * Error Code<br />The error code for this error.<br /><br />**E1431** - System error<br />**E1432** - Required field<br />**E1433** - Invalid field<br />**E1434** - Invalid action<br />**E1435** - Item not found<br />
     * @type {string}
     * @memberof ErrorDetail
     */
    ErrorCode?: string;
    /**
     * Error Log Id<br />The associated Error Log Id if exists.
     * @type {string}
     * @memberof ErrorDetail
     */
    ErrorId?: string;
}
/**
 * An Item that is stored for use in shipment requests.
 * @export
 * @interface Item
 */
export interface Item {
    /**
     * Unique ID<br />Your unique identifier for this item.<br />If not provided, a GUID will be generated.
     * @type {string}
     * @memberof Item
     */
    ItemId?: string;
    /**
     * Item Description
     * @type {string}
     * @memberof Item
     */
    Description: string;
    /**
     * Item Value
     * @type {number}
     * @memberof Item
     */
    Value: number;
    /**
     * Currency<br />3 digit ISO Currency Code
     * @type {string}
     * @memberof Item
     */
    Currency: string;
    /**
     * Item Weight<br />The weight of this item.<br />Min weight: 1 gram.
     * @type {number}
     * @memberof Item
     */
    Weight?: number;
    /**
     * Weight Unit of Measure<br />If using Grams, minimum weight is 1 and partial numbers will be ignored.
     * @type {string}
     * @memberof Item
     */
    WeightUnitOfMeasure?: ItemWeightUnitOfMeasureEnum;
    /**
     * HS Code<br />The [standardised commodity code](https://www.gov.uk/trade-tariff). It must be 6-12 digits only.<br />Used by Customs to calculate potential duties / taxes.
     * @type {string}
     * @memberof Item
     */
    HsCode?: string;
    /**
     * SKU Code.<br />Used by Customs to calculate potential duties / taxes.
     * @type {string}
     * @memberof Item
     */
    SkuCode?: string;
    /**
     * Country of Origin<br />[ISO Alpha-2 Country Code](https://www.nationsonline.org/oneworld/country_code_list.htm) of item country of origin, per ISO 3166 Standard
     * @type {string}
     * @memberof Item
     */
    CountryOfOrigin?: string;
    /**
     * Image URL<br />Used to save a link to an image of the item with the shipment details, so that this can be used in the Returns<br />system for consumers to see an image of the item when selecting items for return.<br />URL must be a publicly accessible image.
     * @type {string}
     * @memberof Item
     */
    ImageUrl?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ItemWeightUnitOfMeasureEnum {
    KG = 'KG',
    Grams = 'Grams'
}

/**
 * Response from a delete item request.
 * @export
 * @interface ItemResponse
 */
export interface ItemResponse {
    /**
     * Item Id<br />The Id of the Item involved in the request, or in the case of create, the created Id, if not provided.
     * @type {string}
     * @memberof ItemResponse
     */
    ItemId?: string;
    /**
     * HTTP Status Code
     * @type {number}
     * @memberof ItemResponse
     */
    HttpStatusCode: number;
    /**
     * HTTP Status Description
     * @type {string}
     * @memberof ItemResponse
     */
    HttpStatusDescription: string;
    /**
     * Message<br />Successful response may include a success message.<br />Failure responses will have general reason as to why. Further details may be contained in the list of errors.
     * @type {string}
     * @memberof ItemResponse
     */
    Message?: string;
    /**
     * Errors<br />Details about why a request failed.
     * @type {Array<ErrorDetail>}
     * @memberof ItemResponse
     */
    Errors?: Array<ErrorDetail>;
}
/**
 * Details of a Manifest that is returned when manifests are successfully created.
 * @export
 * @interface Manifest
 */
export interface Manifest {
    /**
     * Manifest Number
     * @type {string}
     * @memberof Manifest
     */
    ManifestNumber?: string;
    /**
     * Manifest Image<br />A base 64 encoded string of the manifest PDF.
     * @type {string}
     * @memberof Manifest
     */
    ManifestImage?: string;
    /**
     * Carrier Code<br />The carrier that this manifest is for.
     * @type {string}
     * @memberof Manifest
     */
    CarrierCode?: string;
    /**
     * Service Code<br />The service included in this Manifest. If more than one, Mixed will be returned.
     * @type {string}
     * @memberof Manifest
     */
    ServiceCode?: string;
    /**
     * Total Weight<br />Sum of the weight of all the packages included on the Manifest in KGs.
     * @type {number}
     * @memberof Manifest
     */
    TotalWeight?: number;
    /**
     * Total Packages<br />The total number of packages included on the Manifest.
     * @type {number}
     * @memberof Manifest
     */
    TotalPackages?: number;
}
/**
 * A request to manifest shipments created with the given carrier codes that are ready to manifest for a single posting location.
 * @export
 * @interface ManifestCarrierCodesRequest
 */
export interface ManifestCarrierCodesRequest {
    /**
     * Carrier Codes<br />Must be valid system carrier codes.
     * @type {Array<string>}
     * @memberof ManifestCarrierCodesRequest
     */
    CarrierCodes: Array<string>;
    /**
     * Posting Location.<br />Optional if you only have 1 Posting Location.
     * @type {string}
     * @memberof ManifestCarrierCodesRequest
     */
    PostingLocation: string;
}
/**
 * A request to manifest all shipments ready to manifest for a single posting location.
 * @export
 * @interface ManifestRequest
 */
export interface ManifestRequest {
    /**
     * Posting Location.<br />Optional if you only have 1 Posting Location.
     * @type {string}
     * @memberof ManifestRequest
     */
    PostingLocation: string;
}
/**
 * Response from a create manifest request
 * @export
 * @interface ManifestResponse
 */
export interface ManifestResponse {
    /**
     * Posting Location.<br />The Posting Location manifested
     * @type {string}
     * @memberof ManifestResponse
     */
    PostingLocation: string;
    /**
     * The Created Manifests<br />Only populated if the request was successful.
     * @type {Array<Manifest>}
     * @memberof ManifestResponse
     */
    Manifests?: Array<Manifest>;
    /**
     * HTTP Status Code
     * @type {number}
     * @memberof ManifestResponse
     */
    HttpStatusCode: number;
    /**
     * HTTP Status Description
     * @type {string}
     * @memberof ManifestResponse
     */
    HttpStatusDescription: string;
    /**
     * Message<br />Successful response may include a success message.<br />Failure responses will have general reason as to why. Further details may be contained in the list of errors.
     * @type {string}
     * @memberof ManifestResponse
     */
    Message?: string;
    /**
     * Errors<br />Details about why a request failed.
     * @type {Array<ErrorDetail>}
     * @memberof ManifestResponse
     */
    Errors?: Array<ErrorDetail>;
}
/**
 * A request to manifest shipments created with the given service codes that are ready to manifest for a single posting location.
 * @export
 * @interface ManifestServiceCodesRequest
 */
export interface ManifestServiceCodesRequest {
    /**
     * Service Codes<br />Must be valid system service codes OR customer mapped service codes.
     * @type {Array<string>}
     * @memberof ManifestServiceCodesRequest
     */
    ServiceCodes: Array<string>;
    /**
     * Posting Location.<br />Optional if you only have 1 Posting Location.
     * @type {string}
     * @memberof ManifestServiceCodesRequest
     */
    PostingLocation: string;
}
/**
 * Individual Package Response within a Shipment Response.<br />Every successful response will have one of these per package request.
 * @export
 * @interface PackageResponse
 */
export interface PackageResponse {
    /**
     * Package Occurence<br />Unique package number within this shipment
     * @type {number}
     * @memberof PackageResponse
     */
    PackageOccurance: number;
    /**
     * Unique Shipment ID<br />All shipments are assigned a unique Shipment ID.
     * @type {string}
     * @memberof PackageResponse
     */
    UniqueId?: string;
    /**
     * Shipment Tracking Number<br />Final Mile carrier tracking number.<br />Only populated for services that support tracking numbers.
     * @type {string}
     * @memberof PackageResponse
     */
    TrackingNumber?: string;
    /**
     * Tracking URL<br />Final Mile Tracking, if available.
     * @type {string}
     * @memberof PackageResponse
     */
    TrackingUrl?: string;
    /**
     * Carrier Code<br />The allocated carrier.
     * @type {string}
     * @memberof PackageResponse
     */
    CarrierCode?: string;
    /**
     * Primary 2D Barcode Image<br />Only populated for Data Stream response.<br />Base64 Encoded PNG Image of the 2D data matrix barcode.
     * @type {string}
     * @memberof PackageResponse
     */
    Primary2DBarcodeImage?: string;
    /**
     * Primary 2D Barcode Data - Base 64 Encoded<br />Only populated for Data Stream response.<br />Data required to create your own 2D data matrix barcode. Please decode before use.
     * @type {string}
     * @memberof PackageResponse
     */
    Primary2DBarcodeData?: string;
    /**
     * Formatted Unique Id<br />Only populated for Data Stream response.<br />Label for 2D data matrix barcode.
     * @type {string}
     * @memberof PackageResponse
     */
    FormattedUniqueId?: string;
    /**
     * High Volume Barcode Data<br />Only populated for Data Stream response where the service requires the barcode on the label.<br />Data required to create your own High Volume barcode.
     * @type {string}
     * @memberof PackageResponse
     */
    HighVolumeBarcodeData?: string;
    /**
     * High Volume Barcode Image<br />Only populated for Data Stream response where the service requires the barcode on the label.<br />Base64 Encoded PNG Image of the High Volume barcode.
     * @type {string}
     * @memberof PackageResponse
     */
    HighVolumeBarcodeImage?: string;
    /**
     * High Volume Sort Code<br />Only populated for Data Stream response where the service requires the sort code on the label.
     * @type {string}
     * @memberof PackageResponse
     */
    HighVolumeSortCode?: string;
    /**
     * Primary 1D Barcode Data<br />Only populated for Data Stream response where the service requires the barcode on the label.<br />Data required to create your own 1D barcode.
     * @type {string}
     * @memberof PackageResponse
     */
    Primary1DBarcodeData?: string;
    /**
     * Primary 1D Barcode Image<br />Only populated for Data Stream response where the service requires the barcode on the label.<br />Base64 Encoded PNG Image of the 1D barcode.
     * @type {string}
     * @memberof PackageResponse
     */
    Primary1DBarcodeImage?: string;
}
/**
 * Packaging details that are stored, to be used in shipment requests.
 * @export
 * @interface Packaging
 */
export interface Packaging {
    /**
     * Packaging Unique ID<br />Your unique identifier for these packaging details.<br />If not provided, a GUID will be generated.
     * @type {string}
     * @memberof Packaging
     */
    PackagingId?: string;
    /**
     * Name<br />The descriptive name of these packaging details
     * @type {string}
     * @memberof Packaging
     */
    Name: string;
    /**
     * Packaging Weight<br />The weight of this packaging.<br />Min weight: 1 gram.
     * @type {number}
     * @memberof Packaging
     */
    Weight?: number;
    /**
     * Weight Unit of Measure
     * @type {string}
     * @memberof Packaging
     */
    WeightUnitOfMeasure?: PackagingWeightUnitOfMeasureEnum;
    /**
     * Packaging Length<br />The length of this packaging in CM
     * @type {number}
     * @memberof Packaging
     */
    Length: number;
    /**
     * Packaging Width<br />The width of this packaging in CM
     * @type {number}
     * @memberof Packaging
     */
    Width: number;
    /**
     * Packaging Height<br />The height of this packaging in CM
     * @type {number}
     * @memberof Packaging
     */
    Height: number;
}

/**
    * @export
    * @enum {string}
    */
export enum PackagingWeightUnitOfMeasureEnum {
    KG = 'KG',
    Grams = 'Grams'
}

/**
 * Response from a delete packaging details request.
 * @export
 * @interface PackagingResponse
 */
export interface PackagingResponse {
    /**
     * Packaging Id<br />The Id of the Packaging Details involved in the request.
     * @type {string}
     * @memberof PackagingResponse
     */
    PackagingId?: string;
    /**
     * HTTP Status Code
     * @type {number}
     * @memberof PackagingResponse
     */
    HttpStatusCode: number;
    /**
     * HTTP Status Description
     * @type {string}
     * @memberof PackagingResponse
     */
    HttpStatusDescription: string;
    /**
     * Message<br />Successful response may include a success message.<br />Failure responses will have general reason as to why. Further details may be contained in the list of errors.
     * @type {string}
     * @memberof PackagingResponse
     */
    Message?: string;
    /**
     * Errors<br />Details about why a request failed.
     * @type {Array<ErrorDetail>}
     * @memberof PackagingResponse
     */
    Errors?: Array<ErrorDetail>;
}
/**
 * A request to print a document for a shipment
 * @export
 * @interface PrintDocumentRequest
 */
export interface PrintDocumentRequest {
    /**
     * Document Type<br />What document you would like printed<br />            <br />**CN23** - Customs Documents PDF 100mm x 150mm<br />**CI** - Commercial Invoice PDF A4 Portrait<br />**P** - Proforma PDF A4 Portrait
     * @type {string}
     * @memberof PrintDocumentRequest
     */
    DocumentType: PrintDocumentRequestDocumentTypeEnum;
    /**
     * Silent Print Profile<br />If present, resulting documents will be printed using this profile.
     * @type {string}
     * @memberof PrintDocumentRequest
     */
    SilentPrintProfile?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum PrintDocumentRequestDocumentTypeEnum {
    CN23 = 'CN23',
    CI = 'CI',
    P = 'P'
}

/**
 * Response from a print documents request, containing the documents if the request was successful.
 * @export
 * @interface PrintDocumentResponse
 */
export interface PrintDocumentResponse {
    /**
     * Shipment Id<br />Tracking Number or Unique Id of the shipment involved.
     * @type {string}
     * @memberof PrintDocumentResponse
     */
    ShipmentId?: string;
    /**
     * Document Type<br />            <br />**CN23** - Customs Documents PDF 100mm x 150mm<br />**CI** - Commercial Invoice PDF A4 Portrait<br />**P** - Proforma PDF A4 Portrait
     * @type {string}
     * @memberof PrintDocumentResponse
     */
    DocumentType?: PrintDocumentResponseDocumentTypeEnum;
    /**
     * Document Image<br />Base 64 encoded PDF
     * @type {string}
     * @memberof PrintDocumentResponse
     */
    DocumentImage?: string;
    /**
     * HTTP Status Code
     * @type {number}
     * @memberof PrintDocumentResponse
     */
    HttpStatusCode: number;
    /**
     * HTTP Status Description
     * @type {string}
     * @memberof PrintDocumentResponse
     */
    HttpStatusDescription: string;
    /**
     * Message<br />Successful response may include a success message.<br />Failure responses will have general reason as to why. Further details may be contained in the list of errors.
     * @type {string}
     * @memberof PrintDocumentResponse
     */
    Message?: string;
    /**
     * Errors<br />Details about why a request failed.
     * @type {Array<ErrorDetail>}
     * @memberof PrintDocumentResponse
     */
    Errors?: Array<ErrorDetail>;
}

/**
    * @export
    * @enum {string}
    */
export enum PrintDocumentResponseDocumentTypeEnum {
    CN23 = 'CN23',
    CI = 'CI',
    P = 'P'
}

/**
 * A request to print a label
 * @export
 * @interface PrintLabelRequest
 */
export interface PrintLabelRequest {
    /**
     * Requested Label Format<br />*DATASTREAM is only available if it has been activated on your account.*
     * @type {string}
     * @memberof PrintLabelRequest
     */
    LabelFormat?: PrintLabelRequestLabelFormatEnum;
    /**
     * Silent Print Profile<br />If present, resulting labels will be printed using this profile.
     * @type {string}
     * @memberof PrintLabelRequest
     */
    SilentPrintProfile?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum PrintLabelRequestLabelFormatEnum {
    PDF = 'PDF',
    PNG = 'PNG',
    DATASTREAM = 'DATASTREAM',
    ZPL203DPI = 'ZPL203DPI',
    ZPL300DPI = 'ZPL300DPI'
}

/**
 * Response from a print label request, containing the label if the request was successful.
 * @export
 * @interface PrintLabelResponse
 */
export interface PrintLabelResponse {
    /**
     * Shipment Id<br />Tracking Number or Unique Id of the shipment involved.
     * @type {string}
     * @memberof PrintLabelResponse
     */
    ShipmentId?: string;
    /**
     * Label Image<br />Depends on Label Image Format<br />            <br />**PDF**<br />Base 64 encoded PDF<br />            <br />**PNG**<br />Base 64 encoded PNG<br />            <br />**ZPL 300 / 203 dpi**<br />Base 64 encoded PRN (text file)<br />            <br />**Data stream**<br />Not Included
     * @type {string}
     * @memberof PrintLabelResponse
     */
    LabelImage?: string;
    /**
     * Label Image Format
     * @type {string}
     * @memberof PrintLabelResponse
     */
    LabelImageFormat?: PrintLabelResponseLabelImageFormatEnum;
    /**
     * Shipment Tracking Number<br />Final Mile carrier tracking number
     * @type {string}
     * @memberof PrintLabelResponse
     */
    TrackingNumber?: string;
    /**
     * Unique Shipment ID
     * @type {string}
     * @memberof PrintLabelResponse
     */
    UniqueId?: string;
    /**
     * Tracking URL<br />Final Mile Tracking, if available
     * @type {string}
     * @memberof PrintLabelResponse
     */
    TrackingUrl?: string;
    /**
     * Carrier Code<br />The allocated carrier.
     * @type {string}
     * @memberof PrintLabelResponse
     */
    CarrierCode?: string;
    /**
     * Primary 2D Barcode Image<br />Only populated for Data Stream response.<br />Base64 Encoded PNG Image of the 2D data matrix barcode.
     * @type {string}
     * @memberof PrintLabelResponse
     */
    Primary2DBarcodeImage?: string;
    /**
     * Primary 2D Barcode Data - Base 64 Encoded<br />Only populated for Data Stream response.<br />Data required to create your own 2D data matrix barcode. Please decode before use.
     * @type {string}
     * @memberof PrintLabelResponse
     */
    Primary2DBarcodeData?: string;
    /**
     * Formatted Unique Id<br />Only populated for Data Stream response.<br />Label for 2D data matrix barcode.
     * @type {string}
     * @memberof PrintLabelResponse
     */
    FormattedUniqueId?: string;
    /**
     * High Volume Barcode Data<br />Only populated for Data Stream response where the service requires the barcode on the label.<br />Data required to create your own High Volume barcode.
     * @type {string}
     * @memberof PrintLabelResponse
     */
    HighVolumeBarcodeData?: string;
    /**
     * High Volume Barcode Image<br />Only populated for Data Stream response where the service requires the barcode on the label.<br />Base64 Encoded PNG Image of the High Volume barcode.
     * @type {string}
     * @memberof PrintLabelResponse
     */
    HighVolumeBarcodeImage?: string;
    /**
     * High Volume Sort Code<br />Only populated for Data Stream response where the service requires the sort code on the label.
     * @type {string}
     * @memberof PrintLabelResponse
     */
    HighVolumeSortCode?: string;
    /**
     * Primary 1D Barcode Data<br />Only populated for Data Stream response where the service requires the barcode on the label.<br />Data required to create your own 1D barcode.
     * @type {string}
     * @memberof PrintLabelResponse
     */
    Primary1DBarcodeData?: string;
    /**
     * Primary 1D Barcode Image<br />Only populated for Data Stream response where the service requires the barcode on the label.<br />Base64 Encoded PNG Image of the 1D barcode.
     * @type {string}
     * @memberof PrintLabelResponse
     */
    Primary1DBarcodeImage?: string;
    /**
     * Return Label Image Format
     * @type {string}
     * @memberof PrintLabelResponse
     */
    ReturnLabelImageFormat?: PrintLabelResponseReturnLabelImageFormatEnum;
    /**
     * Return Label Image<br />Any return label that have been created as a result of the request and label option settings.<br />Depends on ReturnLabelImageFormat.<br />            <br />**PDF**<br />Base 64 encoded PDF<br />            <br />**PNG**<br />Base 64 encoded PNG<br />            <br />**ZPL 300 / 203 dpi**<br />Base 64 encoded PRN (text file)
     * @type {string}
     * @memberof PrintLabelResponse
     */
    ReturnLabelImage?: string;
    /**
     * HTTP Status Code
     * @type {number}
     * @memberof PrintLabelResponse
     */
    HttpStatusCode: number;
    /**
     * HTTP Status Description
     * @type {string}
     * @memberof PrintLabelResponse
     */
    HttpStatusDescription: string;
    /**
     * Message<br />Successful response may include a success message.<br />Failure responses will have general reason as to why. Further details may be contained in the list of errors.
     * @type {string}
     * @memberof PrintLabelResponse
     */
    Message?: string;
    /**
     * Errors<br />Details about why a request failed.
     * @type {Array<ErrorDetail>}
     * @memberof PrintLabelResponse
     */
    Errors?: Array<ErrorDetail>;
}

/**
    * @export
    * @enum {string}
    */
export enum PrintLabelResponseLabelImageFormatEnum {
    PDF = 'PDF',
    PNG = 'PNG',
    DATASTREAM = 'DATASTREAM',
    ZPL203DPI = 'ZPL203DPI',
    ZPL300DPI = 'ZPL300DPI'
}
/**
    * @export
    * @enum {string}
    */
export enum PrintLabelResponseReturnLabelImageFormatEnum {
    PDF = 'PDF',
    PNG = 'PNG',
    ZPL300DPI = 'ZPL300DPI',
    ZPL203DPI = 'ZPL203DPI'
}

/**
 * The Destination<br />Where the parcel is going to.
 * @export
 * @interface ServiceAvailabilityDestination
 */
export interface ServiceAvailabilityDestination {
    /**
     * Destination Address ID<br />If supplied all destination address fields will be ignored and the stored address will be used.
     * @type {string}
     * @memberof ServiceAvailabilityDestination
     */
    AddressId?: string;
    /**
     * Town<br />Required if Address Id is not provided.
     * @type {string}
     * @memberof ServiceAvailabilityDestination
     */
    Town?: string;
    /**
     * Country Code<br />[ISO Alpha-2 Country Code](https://www.nationsonline.org/oneworld/country_code_list.htm)  per ISO 3166 Standard.  Required if Address Id is not provided
     * @type {string}
     * @memberof ServiceAvailabilityDestination
     */
    CountryCode?: string;
    /**
     * Postcode / Zip<br />Mandatory for all domestic destinations and some international destinations if the Address Id is not provided.
     * @type {string}
     * @memberof ServiceAvailabilityDestination
     */
    Postcode?: string;
}
/**
 * Available Format for a service, with the maximum possible weight allowed.
 * @export
 * @interface ServiceAvailabilityFormat
 */
export interface ServiceAvailabilityFormat {
    /**
     * Service Format<br />An available service format for this service.<br />If blank, then formats are not applicable for this service.<br />            <br />**L** - Letter<br />**F** - Large Letter<br />**P** - Parcel<br />**S** - Printed Papers<br />**Blank** - Not Applicable
     * @type {string}
     * @memberof ServiceAvailabilityFormat
     */
    ServiceFormat?: ServiceAvailabilityFormatServiceFormatEnum;
    /**
     * Format Description<br />A description of the Service Format<br />            <br />Letter<br />Large Letter<br />Parcel<br />International Printed Papaers<br />Not Applicable
     * @type {string}
     * @memberof ServiceAvailabilityFormat
     */
    FormatDescription: string;
    /**
     * Maximum Weight<br />The maximum weight allowed for this format (or service if formats not applicable) in specified Unit of Measure.
     * @type {number}
     * @memberof ServiceAvailabilityFormat
     */
    MaxWeight: number;
}

/**
    * @export
    * @enum {string}
    */
export enum ServiceAvailabilityFormatServiceFormatEnum {
    L = 'L',
    F = 'F',
    P = 'P',
    S = 'S'
}

/**
 * An available service option based on your request.
 * @export
 * @interface ServiceAvailabilityOption
 */
export interface ServiceAvailabilityOption {
    /**
     * Service Code<br />Customer Mapped Service Code or System Service Code for this service.
     * @type {string}
     * @memberof ServiceAvailabilityOption
     */
    ServiceCode: string;
    /**
     * Service Name
     * @type {string}
     * @memberof ServiceAvailabilityOption
     */
    ServiceName: string;
    /**
     * Estimated Transit Days
     * @type {number}
     * @memberof ServiceAvailabilityOption
     */
    TransitDays: number;
    /**
     * Is Tracked<br />If true, the service is a tracked service.
     * @type {boolean}
     * @memberof ServiceAvailabilityOption
     */
    IsTracked: boolean;
    /**
     * Signature Included<br />If true, a signature required on delivery is included with the service.
     * @type {boolean}
     * @memberof ServiceAvailabilityOption
     */
    SignatureIncluded: boolean;
    /**
     * Recorded Signed For Enhancement Available<br />If true, the recorded signed for enhancement can be used with this service.
     * @type {boolean}
     * @memberof ServiceAvailabilityOption
     */
    RecordedSignedForAvailable: boolean;
    /**
     * Safe Place Enhancement Available<br />If true, the safe place enhancement can be used with this service.
     * @type {boolean}
     * @memberof ServiceAvailabilityOption
     */
    SafeplaceAvailable: boolean;
    /**
     * Local Collect Enhancement Available<br />If true, the local collect enhancement can be used with this service.
     * @type {boolean}
     * @memberof ServiceAvailabilityOption
     */
    LocalCollectAvailable: boolean;
    /**
     * Saturday Guaranteed Enhancement Available<br />If true, the saturday guaranteed enhancement can be used with this service.
     * @type {boolean}
     * @memberof ServiceAvailabilityOption
     */
    SaturdayGuaranteedAvailable: boolean;
    /**
     * Consequential Loss Enhancement Available<br />If true, the consequential loss enhancement can be used with this service.
     * @type {boolean}
     * @memberof ServiceAvailabilityOption
     */
    ConsequentialLossAvailable: boolean;
    /**
     * Formats Available<br />All formats that are available for this service for the given weight, including the maximum weight possible for each format.
     * @type {Array<ServiceAvailabilityFormat>}
     * @memberof ServiceAvailabilityOption
     */
    FormatsAvailable: Array<ServiceAvailabilityFormat>;
}
/**
 * Response from a Service Availabilty Request
 * @export
 * @interface ServiceAvailabilityResponse
 */
export interface ServiceAvailabilityResponse {
    /**
     * Weight Unit of Measure<br />The unit of measure used for the Max Weights.<br />Will be the same as the Weight Unit of Measure received.
     * @type {string}
     * @memberof ServiceAvailabilityResponse
     */
    WeightUnitOfMeasure?: ServiceAvailabilityResponseWeightUnitOfMeasureEnum;
    /**
     * Service Options<br />The available service options that can be used for the details provided.<br />Populated for successful responses only.
     * @type {Array<ServiceAvailabilityOption>}
     * @memberof ServiceAvailabilityResponse
     */
    Options?: Array<ServiceAvailabilityOption>;
    /**
     * HTTP Status Code
     * @type {number}
     * @memberof ServiceAvailabilityResponse
     */
    HttpStatusCode: number;
    /**
     * HTTP Status Description
     * @type {string}
     * @memberof ServiceAvailabilityResponse
     */
    HttpStatusDescription: string;
    /**
     * Message<br />Successful response may include a success message.<br />Failure responses will have general reason as to why. Further details may be contained in the list of errors.
     * @type {string}
     * @memberof ServiceAvailabilityResponse
     */
    Message?: string;
    /**
     * Errors<br />Details about why a request failed.
     * @type {Array<ErrorDetail>}
     * @memberof ServiceAvailabilityResponse
     */
    Errors?: Array<ErrorDetail>;
}

/**
    * @export
    * @enum {string}
    */
export enum ServiceAvailabilityResponseWeightUnitOfMeasureEnum {
    KG = 'KG',
    Grams = 'Grams'
}

/**
 * Service Options<br />Specify any service requirements such as format required or enhancements required.
 * @export
 * @interface ServiceAvailabilityServiceOptions
 */
export interface ServiceAvailabilityServiceOptions {
    /**
     * Service Format<br />If provided, only return services that support the given service format.<br />            <br />**L** - Letter<br />**F** - Large Letter<br />**P** - Parcel<br />**S** - Printed Papers - International Services Only
     * @type {string}
     * @memberof ServiceAvailabilityServiceOptions
     */
    ServiceFormat?: ServiceAvailabilityServiceOptionsServiceFormatEnum;
    /**
     * Tracked Services<br />If true, only return Tracked Services.
     * @type {boolean}
     * @memberof ServiceAvailabilityServiceOptions
     */
    Tracked?: boolean;
    /**
     * Signature Required<br />If true, only return services that are either with signature or support the Recorded Signed For enhancement.
     * @type {boolean}
     * @memberof ServiceAvailabilityServiceOptions
     */
    SignatureRequired?: boolean;
    /**
     * Safe Place Enhancement<br />If true, only return services that support the Safe Place enhancement.
     * @type {boolean}
     * @memberof ServiceAvailabilityServiceOptions
     */
    Safeplace?: boolean;
    /**
     * Local Collect Enhancement<br />If true, only return services that support the Local Collect enhancement.
     * @type {boolean}
     * @memberof ServiceAvailabilityServiceOptions
     */
    LocalCollect?: boolean;
    /**
     * Saturday Guaranteed Enhancement<br />If true, only return services that support the Saturday Guaranteed enhancement.
     * @type {boolean}
     * @memberof ServiceAvailabilityServiceOptions
     */
    SaturdayGuaranteed?: boolean;
    /**
     * Consequential Loss Enhancement<br />If true, only return services that support the Consequential Loss enhancement.
     * @type {boolean}
     * @memberof ServiceAvailabilityServiceOptions
     */
    ConsequentialLoss?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum ServiceAvailabilityServiceOptionsServiceFormatEnum {
    L = 'L',
    F = 'F',
    P = 'P',
    S = 'S'
}

/**
 * Details of a shipment for a service availability check.
 * @export
 * @interface ServiceAvailabilityShipment
 */
export interface ServiceAvailabilityShipment {
    /**
     * 
     * @type {ServiceAvailabilityDestination}
     * @memberof ServiceAvailabilityShipment
     */
    Destination: ServiceAvailabilityDestination;
    /**
     * 
     * @type {ServiceAvailabilityShipmentInformation}
     * @memberof ServiceAvailabilityShipment
     */
    ShipmentInformation: ServiceAvailabilityShipmentInformation;
}
/**
 * Shipment Information<br />Overall package details and requested service requirements.
 * @export
 * @interface ServiceAvailabilityShipmentInformation
 */
export interface ServiceAvailabilityShipmentInformation {
    /**
     * Service Code<br />Must be a valid system service code OR a customer mapped service code.<br />If service code is not supplied a list of all available service options will be returned, otherwise only information about the service requested will be returned.
     * @type {string}
     * @memberof ServiceAvailabilityShipmentInformation
     */
    ServiceCode?: string;
    /**
     * 
     * @type {ServiceAvailabilityServiceOptions}
     * @memberof ServiceAvailabilityShipmentInformation
     */
    ServiceOptions?: ServiceAvailabilityServiceOptions;
    /**
     * Number of Packages<br />The total number of packages.
     * @type {number}
     * @memberof ServiceAvailabilityShipmentInformation
     */
    TotalPackages: number;
    /**
     * Total Weight<br />The total weight of the shipment including packaging. Validated againt package weight.<br />Min weight: 1 gram.
     * @type {number}
     * @memberof ServiceAvailabilityShipmentInformation
     */
    TotalWeight: number;
    /**
     * Weight Unit of Measure
     * @type {string}
     * @memberof ServiceAvailabilityShipmentInformation
     */
    WeightUnitOfMeasure?: ServiceAvailabilityShipmentInformationWeightUnitOfMeasureEnum;
    /**
     * Shipment/Product type being shipped<br />            <br />**DOX** - Documents Only<br />**NDX** - All other shipment product types
     * @type {string}
     * @memberof ServiceAvailabilityShipmentInformation
     */
    Product?: ServiceAvailabilityShipmentInformationProductEnum;
    /**
     * Total Shipment Value<br />Required for Non-Document International and BFPO Shipments.<br />Ignored for Documents Only shipments.
     * @type {number}
     * @memberof ServiceAvailabilityShipmentInformation
     */
    Value?: number;
    /**
     * Currency<br />This currency will be used for all values across the shipment request.<br />3 digit ISO Currency Code.<br />Required for Non-Document International and BFPO Shipments, or when value is provided.<br />Ignored for Documents Only shipments.
     * @type {string}
     * @memberof ServiceAvailabilityShipmentInformation
     */
    Currency?: string;
    /**
     * Shipment Packages<br />The packages in the shipment.<br />Required if TotalPackages is more than 1.
     * @type {Array<ServiceAvailabilityShipmentPackage>}
     * @memberof ServiceAvailabilityShipmentInformation
     */
    Packages?: Array<ServiceAvailabilityShipmentPackage>;
}

/**
    * @export
    * @enum {string}
    */
export enum ServiceAvailabilityShipmentInformationWeightUnitOfMeasureEnum {
    KG = 'KG',
    Grams = 'Grams'
}
/**
    * @export
    * @enum {string}
    */
export enum ServiceAvailabilityShipmentInformationProductEnum {
    NDX = 'NDX',
    DOX = 'DOX'
}

/**
 * Details of a package in a shipment request.<br />Enter the dimensions and weight of the package in the shipment. Use the PackageOccurance to indicate the items within the package.
 * @export
 * @interface ServiceAvailabilityShipmentPackage
 */
export interface ServiceAvailabilityShipmentPackage {
    /**
     * Package Occurrence<br />Unique package number within this shipment.<br />Cannot exceed total number of packages.
     * @type {number}
     * @memberof ServiceAvailabilityShipmentPackage
     */
    PackageOccurrence: number;
    /**
     * Packaging ID<br />If supplied, packaging details will be populated from the stored information.
     * @type {string}
     * @memberof ServiceAvailabilityShipmentPackage
     */
    PackagingId?: string;
    /**
     * Total Package Weight.<br />            <br />This field will be used as the Shipment Weight for single-package services such as RMG.<br />The package weight must be greater than or equal to the sum of all item weights and packaging, if this information is provided.<br />Min weight: 1 gram.
     * @type {number}
     * @memberof ServiceAvailabilityShipmentPackage
     */
    Weight: number;
    /**
     * Package Length<br />Dimensions are in Centimetres.<br />*Dimensions are optional, however supplying accurate information helps ensure a smooth delivery experience.*
     * @type {number}
     * @memberof ServiceAvailabilityShipmentPackage
     */
    Length?: number;
    /**
     * Package Width<br />Dimensions are in Centimetres.<br />*Dimensions are optional, however supplying accurate information helps ensure a smooth delivery experience.*
     * @type {number}
     * @memberof ServiceAvailabilityShipmentPackage
     */
    Width?: number;
    /**
     * Package Height<br />Dimensions are in Centimetres.<br />*Dimensions are optional, however supplying accurate information helps ensure a smooth delivery experience.*
     * @type {number}
     * @memberof ServiceAvailabilityShipmentPackage
     */
    Height?: number;
}
/**
 * A request to cancel a shipment.
 * @export
 * @interface ShipmentCancelRequest
 */
export interface ShipmentCancelRequest {
    /**
     * Shipment Id<br />The tracking number or Unique Id of the shipment to cancel.
     * @type {string}
     * @memberof ShipmentCancelRequest
     */
    ShipmentId: string;
    /**
     * Reason for Cancellation
     * @type {string}
     * @memberof ShipmentCancelRequest
     */
    ReasonForCancellation: ShipmentCancelRequestReasonForCancellationEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ShipmentCancelRequestReasonForCancellationEnum {
    OrderCancelled = 'OrderCancelled',
    Repacked = 'Repacked',
    UploadedInError = 'UploadedInError',
    WrongService = 'WrongService'
}

/**
 * Response from a create shipment request
 * @export
 * @interface ShipmentCreateResponse
 */
export interface ShipmentCreateResponse {
    /**
     * Consignment Number<br />Only populated for services that support Multi-Packages
     * @type {string}
     * @memberof ShipmentCreateResponse
     */
    ConsignmentNumber?: string;
    /**
     * Consignment Tracking URL<br />Only populated for services that support Multi-Packages
     * @type {string}
     * @memberof ShipmentCreateResponse
     */
    ConsignmentTrackingUrl?: string;
    /**
     * Packages<br />Details each package tracking information and Unique Id.
     * @type {Array<PackageResponse>}
     * @memberof ShipmentCreateResponse
     */
    Packages?: Array<PackageResponse>;
    /**
     * Label Image Format
     * @type {string}
     * @memberof ShipmentCreateResponse
     */
    LabelImageFormat?: ShipmentCreateResponseLabelImageFormatEnum;
    /**
     * Label Images<br />Any labels that have been created as a result of the request.<br />Depends on Label Image Format.<br />            <br />**PDF**<br />Base 64 encoded PDF<br />            <br />**PNG**<br />Base 64 encoded PNG<br />            <br />**ZPL 300 / 203 dpi**<br />Base 64 encoded PRN (text file)<br />            <br />**Data stream**<br />Not Included - see Packages for Data Stream responses
     * @type {string}
     * @memberof ShipmentCreateResponse
     */
    LabelImages?: string;
    /**
     * Customs Documents<br />Base 64 encoded PDF<br />Any customs documents that have been created as a result of the request.
     * @type {string}
     * @memberof ShipmentCreateResponse
     */
    CustomsDocuments?: string;
    /**
     * Return Label Image Format
     * @type {string}
     * @memberof ShipmentCreateResponse
     */
    ReturnLabelImageFormat?: ShipmentCreateResponseReturnLabelImageFormatEnum;
    /**
     * Return Label Images<br />Any return labels that have been created as a result of the request and label option settings.<br />Depends on ReturnLabelImageFormat.<br />            <br />**PDF**<br />Base 64 encoded PDF<br />            <br />**PNG**<br />Base 64 encoded PNG<br />            <br />**ZPL 300 / 203 dpi**<br />Base 64 encoded PRN (text file)
     * @type {string}
     * @memberof ShipmentCreateResponse
     */
    ReturnLabelImages?: string;
    /**
     * HTTP Status Code
     * @type {number}
     * @memberof ShipmentCreateResponse
     */
    HttpStatusCode: number;
    /**
     * HTTP Status Description
     * @type {string}
     * @memberof ShipmentCreateResponse
     */
    HttpStatusDescription: string;
    /**
     * Message<br />Successful response may include a success message.<br />Failure responses will have general reason as to why. Further details may be contained in the list of errors.
     * @type {string}
     * @memberof ShipmentCreateResponse
     */
    Message?: string;
    /**
     * Errors<br />Details about why a request failed.
     * @type {Array<ErrorDetail>}
     * @memberof ShipmentCreateResponse
     */
    Errors?: Array<ErrorDetail>;
}

/**
    * @export
    * @enum {string}
    */
export enum ShipmentCreateResponseLabelImageFormatEnum {
    PDF = 'PDF',
    PNG = 'PNG',
    DATASTREAM = 'DATASTREAM',
    ZPL203DPI = 'ZPL203DPI',
    ZPL300DPI = 'ZPL300DPI'
}
/**
    * @export
    * @enum {string}
    */
export enum ShipmentCreateResponseReturnLabelImageFormatEnum {
    PDF = 'PDF',
    PNG = 'PNG',
    ZPL300DPI = 'ZPL300DPI',
    ZPL203DPI = 'ZPL203DPI'
}

/**
 * A request to defer a shipment to a later date.
 * @export
 * @interface ShipmentDeferRequest
 */
export interface ShipmentDeferRequest {
    /**
     * Shipment Id<br />The tracking number or Unique Id of the shipment to defer.
     * @type {string}
     * @memberof ShipmentDeferRequest
     */
    ShipmentId: string;
    /**
     * Shipment Date<br />Date of despatch – YYYY-MM-DD<br />Cannot be in the past. Max 28 days in the future.
     * @type {string}
     * @memberof ShipmentDeferRequest
     */
    ShipmentDate: string;
}
/**
 * A request to hold a shipment.
 * @export
 * @interface ShipmentHoldRequest
 */
export interface ShipmentHoldRequest {
    /**
     * Shipment Id<br />The tracking number or Unique Id of the shipment to hold.
     * @type {string}
     * @memberof ShipmentHoldRequest
     */
    ShipmentId: string;
    /**
     * Reason for Hold<br />Must match a Hold Reason set in Pro Shipping Maintenance / Hold Reasons.
     * @type {string}
     * @memberof ShipmentHoldRequest
     */
    ReasonForHold: string;
}
/**
 * Details of an item in a shipment request, including what package it is in if possible.
 * @export
 * @interface ShipmentItem
 */
export interface ShipmentItem {
    /**
     * Item ID<br />If supplied all item fields except Item Quantity will be populated from the stored item record.
     * @type {string}
     * @memberof ShipmentItem
     */
    ItemId?: string;
    /**
     * Item Quantity<br />The quantity of items of this type.
     * @type {number}
     * @memberof ShipmentItem
     */
    Quantity: number;
    /**
     * Item Description<br />Required if an Item Id is not supplied.
     * @type {string}
     * @memberof ShipmentItem
     */
    Description?: string;
    /**
     * Item Value<br />Individual item value (use same currency as shipment currency).<br />Required if an Item Id is not supplied.
     * @type {number}
     * @memberof ShipmentItem
     */
    Value?: number;
    /**
     * Item Weight<br />Individual item weight.
     * @type {number}
     * @memberof ShipmentItem
     */
    Weight?: number;
    /**
     * Package Occurrence<br />Optional Package Occurrence used to indicate which package the item has been packed into.
     * @type {number}
     * @memberof ShipmentItem
     */
    PackageOccurrence?: number;
    /**
     * HS Code<br />The [standardised commodity code](https://www.gov.uk/trade-tariff). It must be 6-12 digits only.<br />Used by Customs to calculate potential duties / taxes.
     * @type {string}
     * @memberof ShipmentItem
     */
    HsCode?: string;
    /**
     * SKU Code.<br />Used by Customs to calculate potential duties / taxes.
     * @type {string}
     * @memberof ShipmentItem
     */
    SkuCode?: string;
    /**
     * Country of Origin<br />[ISO Alpha-2 Country Code](https://www.nationsonline.org/oneworld/country_code_list.htm) of item country of origin, per ISO 3166 Standard
     * @type {string}
     * @memberof ShipmentItem
     */
    CountryOfOrigin?: string;
    /**
     * Image URL<br />Used to save a link to an image of the item with the shipment details, so that this can be used in the Returns<br />system for consumers to see an image of the item when selecting items for return.<br />URL must be a publicly accessible image.
     * @type {string}
     * @memberof ShipmentItem
     */
    ImageUrl?: string;
}
/**
 * Response from a cancel shipments request.
 * @export
 * @interface ShipmentsCancelResponse
 */
export interface ShipmentsCancelResponse {
    /**
     * Shipment Ids<br />Tracking Numbers / Unique Ids of each shipment involved in the request.
     * @type {Array<string>}
     * @memberof ShipmentsCancelResponse
     */
    ShipmentIds?: Array<string>;
    /**
     * HTTP Status Code
     * @type {number}
     * @memberof ShipmentsCancelResponse
     */
    HttpStatusCode: number;
    /**
     * HTTP Status Description
     * @type {string}
     * @memberof ShipmentsCancelResponse
     */
    HttpStatusDescription: string;
    /**
     * Message<br />Successful response may include a success message.<br />Failure responses will have general reason as to why. Further details may be contained in the list of errors.
     * @type {string}
     * @memberof ShipmentsCancelResponse
     */
    Message?: string;
    /**
     * Errors<br />Details about why a request failed.
     * @type {Array<ErrorDetail>}
     * @memberof ShipmentsCancelResponse
     */
    Errors?: Array<ErrorDetail>;
}
/**
 * Response from a defer shipments request.
 * @export
 * @interface ShipmentsDeferResponse
 */
export interface ShipmentsDeferResponse {
    /**
     * Shipment Ids<br />Tracking Numbers / Unique Ids of each shipment involved in the request.
     * @type {Array<string>}
     * @memberof ShipmentsDeferResponse
     */
    ShipmentIds?: Array<string>;
    /**
     * HTTP Status Code
     * @type {number}
     * @memberof ShipmentsDeferResponse
     */
    HttpStatusCode: number;
    /**
     * HTTP Status Description
     * @type {string}
     * @memberof ShipmentsDeferResponse
     */
    HttpStatusDescription: string;
    /**
     * Message<br />Successful response may include a success message.<br />Failure responses will have general reason as to why. Further details may be contained in the list of errors.
     * @type {string}
     * @memberof ShipmentsDeferResponse
     */
    Message?: string;
    /**
     * Errors<br />Details about why a request failed.
     * @type {Array<ErrorDetail>}
     * @memberof ShipmentsDeferResponse
     */
    Errors?: Array<ErrorDetail>;
}
/**
 * Response from a hold 1 or more shipments request.
 * @export
 * @interface ShipmentsHoldResponse
 */
export interface ShipmentsHoldResponse {
    /**
     * Shipment Ids<br />Tracking Numbers / Unique Ids of each shipment involved in the request.
     * @type {Array<string>}
     * @memberof ShipmentsHoldResponse
     */
    ShipmentIds?: Array<string>;
    /**
     * HTTP Status Code
     * @type {number}
     * @memberof ShipmentsHoldResponse
     */
    HttpStatusCode: number;
    /**
     * HTTP Status Description
     * @type {string}
     * @memberof ShipmentsHoldResponse
     */
    HttpStatusDescription: string;
    /**
     * Message<br />Successful response may include a success message.<br />Failure responses will have general reason as to why. Further details may be contained in the list of errors.
     * @type {string}
     * @memberof ShipmentsHoldResponse
     */
    Message?: string;
    /**
     * Errors<br />Details about why a request failed.
     * @type {Array<ErrorDetail>}
     * @memberof ShipmentsHoldResponse
     */
    Errors?: Array<ErrorDetail>;
}
/**
 * Request to release 1 or more shipments from hold.
 * @export
 * @interface ShipmentsReleaseRequest
 */
export interface ShipmentsReleaseRequest {
    /**
     * Shipment Ids<br />Tracking Numbers / Unique Ids of each shipment to release from hold.
     * @type {Array<string>}
     * @memberof ShipmentsReleaseRequest
     */
    ShipmentIds?: Array<string>;
}
/**
 * Response from a release 1 or more shipments request.
 * @export
 * @interface ShipmentsReleaseResponse
 */
export interface ShipmentsReleaseResponse {
    /**
     * Shipment Ids<br />Tracking Numbers / Unique Ids of each shipment involved in the request.
     * @type {Array<string>}
     * @memberof ShipmentsReleaseResponse
     */
    ShipmentIds?: Array<string>;
    /**
     * HTTP Status Code
     * @type {number}
     * @memberof ShipmentsReleaseResponse
     */
    HttpStatusCode: number;
    /**
     * HTTP Status Description
     * @type {string}
     * @memberof ShipmentsReleaseResponse
     */
    HttpStatusDescription: string;
    /**
     * Message<br />Successful response may include a success message.<br />Failure responses will have general reason as to why. Further details may be contained in the list of errors.
     * @type {string}
     * @memberof ShipmentsReleaseResponse
     */
    Message?: string;
    /**
     * Errors<br />Details about why a request failed.
     * @type {Array<ErrorDetail>}
     * @memberof ShipmentsReleaseResponse
     */
    Errors?: Array<ErrorDetail>;
}
/**
 * The shipper details for a shipment request.<br />Confirms the details of the shipper address and contact details.<br />If not supplied, the the posting location address will be used.
 * @export
 * @interface Shipper
 */
export interface Shipper {
    /**
     * Shipper Address Id<br />If supplied all shipper address fields will be ignored and the address from the Address Book will be used.
     * @type {string}
     * @memberof Shipper
     */
    AddressId?: string;
    /**
     * Shipper Reference<br />Your reference for this shipment.<br />This field is used for Returns processing and is usually the shippers order number provided to the consumer.
     * @type {string}
     * @memberof Shipper
     */
    ShipperReference?: string;
    /**
     * Shipper Reference2<br />Your reference for this shipment.<br />This field is used for tracking shipment usually the EBAY VTN number provided to the consumer.
     * @type {string}
     * @memberof Shipper
     */
    ShipperReference2?: string;
    /**
     * Shipper Department Code<br />For Royal Mail shipments, this code must be a valid 10-digit OBA department code.
     * @type {string}
     * @memberof Shipper
     */
    ShipperDepartment?: string;
    /**
     * Company Name
     * @type {string}
     * @memberof Shipper
     */
    CompanyName?: string;
    /**
     * Contact Name
     * @type {string}
     * @memberof Shipper
     */
    ContactName?: string;
    /**
     * Address Line 1<br />Populate with Shipper\'s address if provided.
     * @type {string}
     * @memberof Shipper
     */
    AddressLine1?: string;
    /**
     * Address Line 2
     * @type {string}
     * @memberof Shipper
     */
    AddressLine2?: string;
    /**
     * Address Line 3
     * @type {string}
     * @memberof Shipper
     */
    AddressLine3?: string;
    /**
     * Town<br />Required if address is populated.
     * @type {string}
     * @memberof Shipper
     */
    Town?: string;
    /**
     * County / State / Province<br />Whether this is required or not is dependent on the country settings.
     * @type {string}
     * @memberof Shipper
     */
    County?: string;
    /**
     * Country Code<br />[ISO Alpha-2 Country Code](https://www.nationsonline.org/oneworld/country_code_list.htm) per ISO 3166 Standard.<br />Required if address is populated.<br />Must be GB, IM, GG or JE.
     * @type {string}
     * @memberof Shipper
     */
    CountryCode?: string;
    /**
     * Postcode / Zip<br />Mandatory for all domestic addresses and some international shipments if address is populated.
     * @type {string}
     * @memberof Shipper
     */
    Postcode?: string;
    /**
     * Contact Phone Number<br />Must be a valid phone number.
     * @type {string}
     * @memberof Shipper
     */
    PhoneNumber?: string;
    /**
     * Contact Email Address<br />Must be a valid email address.
     * @type {string}
     * @memberof Shipper
     */
    EmailAddress?: string;
    /**
     * VAT Number
     * @type {string}
     * @memberof Shipper
     */
    VatNumber?: string;
}

/**
 * AddressesApi - axios parameter creator
 * @export
 */
export const AddressesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a new address to your address book that you can then use in your shipment requests.
         * @summary Create Address
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {Address} address The address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressesCreate: async (xRMGAuthToken: string, address: Address, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xRMGAuthToken' is not null or undefined
            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                throw new RequiredError('xRMGAuthToken','Required parameter xRMGAuthToken was null or undefined when calling addressesCreate.');
            }
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling addressesCreate.');
            }
            const localVarPath = `/addresses`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication clientID required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-IBM-Client-Id")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
            }

            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof address !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(address !== undefined ? address : {}) : (address || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the specified address.
         * @summary Delete Address
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} addressId Your unique Address ID of the address to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressesDelete: async (xRMGAuthToken: string, addressId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xRMGAuthToken' is not null or undefined
            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                throw new RequiredError('xRMGAuthToken','Required parameter xRMGAuthToken was null or undefined when calling addressesDelete.');
            }
            // verify required parameter 'addressId' is not null or undefined
            if (addressId === null || addressId === undefined) {
                throw new RequiredError('addressId','Required parameter addressId was null or undefined when calling addressesDelete.');
            }
            const localVarPath = `/addresses/{addressId}`
                .replace(`{${"addressId"}}`, encodeURIComponent(String(addressId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication clientID required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-IBM-Client-Id")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
            }

            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the address specified by your unique Address ID.
         * @summary Get Address
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} addressId Your unique Address ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressesGet: async (xRMGAuthToken: string, addressId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xRMGAuthToken' is not null or undefined
            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                throw new RequiredError('xRMGAuthToken','Required parameter xRMGAuthToken was null or undefined when calling addressesGet.');
            }
            // verify required parameter 'addressId' is not null or undefined
            if (addressId === null || addressId === undefined) {
                throw new RequiredError('addressId','Required parameter addressId was null or undefined when calling addressesGet.');
            }
            const localVarPath = `/addresses/{addressId}`
                .replace(`{${"addressId"}}`, encodeURIComponent(String(addressId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication clientID required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-IBM-Client-Id")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
            }

            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all of your stored addresses
         * @summary Get Addresses
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressesGetAll: async (xRMGAuthToken: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xRMGAuthToken' is not null or undefined
            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                throw new RequiredError('xRMGAuthToken','Required parameter xRMGAuthToken was null or undefined when calling addressesGetAll.');
            }
            const localVarPath = `/addresses`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication clientID required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-IBM-Client-Id")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
            }

            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an address that is already in your address book with new details. The whole address will be replaced with<br />new details.
         * @summary Update address
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} addressId Your unique Address ID of the address to update.
         * @param {Address} address The address with the updated details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressesUpdate: async (xRMGAuthToken: string, addressId: string, address: Address, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xRMGAuthToken' is not null or undefined
            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                throw new RequiredError('xRMGAuthToken','Required parameter xRMGAuthToken was null or undefined when calling addressesUpdate.');
            }
            // verify required parameter 'addressId' is not null or undefined
            if (addressId === null || addressId === undefined) {
                throw new RequiredError('addressId','Required parameter addressId was null or undefined when calling addressesUpdate.');
            }
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling addressesUpdate.');
            }
            const localVarPath = `/addresses/{addressId}`
                .replace(`{${"addressId"}}`, encodeURIComponent(String(addressId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication clientID required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-IBM-Client-Id")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
            }

            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof address !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(address !== undefined ? address : {}) : (address || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddressesApi - functional programming interface
 * @export
 */
export const AddressesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Add a new address to your address book that you can then use in your shipment requests.
         * @summary Create Address
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {Address} address The address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressesCreate(xRMGAuthToken: string, address: Address, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressResponse>> {
            const localVarAxiosArgs = await AddressesApiAxiosParamCreator(configuration).addressesCreate(xRMGAuthToken, address, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes the specified address.
         * @summary Delete Address
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} addressId Your unique Address ID of the address to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressesDelete(xRMGAuthToken: string, addressId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressResponse>> {
            const localVarAxiosArgs = await AddressesApiAxiosParamCreator(configuration).addressesDelete(xRMGAuthToken, addressId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the address specified by your unique Address ID.
         * @summary Get Address
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} addressId Your unique Address ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressesGet(xRMGAuthToken: string, addressId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Address>> {
            const localVarAxiosArgs = await AddressesApiAxiosParamCreator(configuration).addressesGet(xRMGAuthToken, addressId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get all of your stored addresses
         * @summary Get Addresses
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressesGetAll(xRMGAuthToken: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Address>>> {
            const localVarAxiosArgs = await AddressesApiAxiosParamCreator(configuration).addressesGetAll(xRMGAuthToken, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update an address that is already in your address book with new details. The whole address will be replaced with<br />new details.
         * @summary Update address
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} addressId Your unique Address ID of the address to update.
         * @param {Address} address The address with the updated details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressesUpdate(xRMGAuthToken: string, addressId: string, address: Address, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressResponse>> {
            const localVarAxiosArgs = await AddressesApiAxiosParamCreator(configuration).addressesUpdate(xRMGAuthToken, addressId, address, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AddressesApi - factory interface
 * @export
 */
export const AddressesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Add a new address to your address book that you can then use in your shipment requests.
         * @summary Create Address
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {Address} address The address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressesCreate(xRMGAuthToken: string, address: Address, options?: any): AxiosPromise<AddressResponse> {
            return AddressesApiFp(configuration).addressesCreate(xRMGAuthToken, address, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the specified address.
         * @summary Delete Address
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} addressId Your unique Address ID of the address to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressesDelete(xRMGAuthToken: string, addressId: string, options?: any): AxiosPromise<AddressResponse> {
            return AddressesApiFp(configuration).addressesDelete(xRMGAuthToken, addressId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the address specified by your unique Address ID.
         * @summary Get Address
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} addressId Your unique Address ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressesGet(xRMGAuthToken: string, addressId: string, options?: any): AxiosPromise<Address> {
            return AddressesApiFp(configuration).addressesGet(xRMGAuthToken, addressId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all of your stored addresses
         * @summary Get Addresses
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressesGetAll(xRMGAuthToken: string, options?: any): AxiosPromise<Array<Address>> {
            return AddressesApiFp(configuration).addressesGetAll(xRMGAuthToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an address that is already in your address book with new details. The whole address will be replaced with<br />new details.
         * @summary Update address
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} addressId Your unique Address ID of the address to update.
         * @param {Address} address The address with the updated details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressesUpdate(xRMGAuthToken: string, addressId: string, address: Address, options?: any): AxiosPromise<AddressResponse> {
            return AddressesApiFp(configuration).addressesUpdate(xRMGAuthToken, addressId, address, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AddressesApi - object-oriented interface
 * @export
 * @class AddressesApi
 * @extends {BaseAPI}
 */
export class AddressesApi extends BaseAPI {
    /**
     * Add a new address to your address book that you can then use in your shipment requests.
     * @summary Create Address
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {Address} address The address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public addressesCreate(xRMGAuthToken: string, address: Address, options?: any) {
        return AddressesApiFp(this.configuration).addressesCreate(xRMGAuthToken, address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the specified address.
     * @summary Delete Address
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {string} addressId Your unique Address ID of the address to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public addressesDelete(xRMGAuthToken: string, addressId: string, options?: any) {
        return AddressesApiFp(this.configuration).addressesDelete(xRMGAuthToken, addressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the address specified by your unique Address ID.
     * @summary Get Address
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {string} addressId Your unique Address ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public addressesGet(xRMGAuthToken: string, addressId: string, options?: any) {
        return AddressesApiFp(this.configuration).addressesGet(xRMGAuthToken, addressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all of your stored addresses
     * @summary Get Addresses
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public addressesGetAll(xRMGAuthToken: string, options?: any) {
        return AddressesApiFp(this.configuration).addressesGetAll(xRMGAuthToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an address that is already in your address book with new details. The whole address will be replaced with<br />new details.
     * @summary Update address
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {string} addressId Your unique Address ID of the address to update.
     * @param {Address} address The address with the updated details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public addressesUpdate(xRMGAuthToken: string, addressId: string, address: Address, options?: any) {
        return AddressesApiFp(this.configuration).addressesUpdate(xRMGAuthToken, addressId, address, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemsApi - axios parameter creator
 * @export
 */
export const ItemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a new item to your stored items that you can then use in your shipment requests.
         * @summary Create Item
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {Item} item The item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsCreate: async (xRMGAuthToken: string, item: Item, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xRMGAuthToken' is not null or undefined
            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                throw new RequiredError('xRMGAuthToken','Required parameter xRMGAuthToken was null or undefined when calling itemsCreate.');
            }
            // verify required parameter 'item' is not null or undefined
            if (item === null || item === undefined) {
                throw new RequiredError('item','Required parameter item was null or undefined when calling itemsCreate.');
            }
            const localVarPath = `/items`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication clientID required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-IBM-Client-Id")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
            }

            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof item !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(item !== undefined ? item : {}) : (item || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the specified item.
         * @summary Delete Item
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} itemId Your unique Item ID of the item to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsDelete: async (xRMGAuthToken: string, itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xRMGAuthToken' is not null or undefined
            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                throw new RequiredError('xRMGAuthToken','Required parameter xRMGAuthToken was null or undefined when calling itemsDelete.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling itemsDelete.');
            }
            const localVarPath = `/items/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication clientID required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-IBM-Client-Id")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
            }

            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the item specified by your unique Item ID.
         * @summary Get Item
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} itemId Your unique Item ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsGet: async (xRMGAuthToken: string, itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xRMGAuthToken' is not null or undefined
            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                throw new RequiredError('xRMGAuthToken','Required parameter xRMGAuthToken was null or undefined when calling itemsGet.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling itemsGet.');
            }
            const localVarPath = `/items/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication clientID required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-IBM-Client-Id")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
            }

            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all of your stored items
         * @summary Get Items
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsGetAll: async (xRMGAuthToken: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xRMGAuthToken' is not null or undefined
            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                throw new RequiredError('xRMGAuthToken','Required parameter xRMGAuthToken was null or undefined when calling itemsGetAll.');
            }
            const localVarPath = `/items`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication clientID required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-IBM-Client-Id")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
            }

            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an item that is already stored with new details. The whole item will be replaced with new details.
         * @summary Update item
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} itemId Your unique Item ID of the item to update.
         * @param {Item} item The item with the updated details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsUpdate: async (xRMGAuthToken: string, itemId: string, item: Item, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xRMGAuthToken' is not null or undefined
            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                throw new RequiredError('xRMGAuthToken','Required parameter xRMGAuthToken was null or undefined when calling itemsUpdate.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling itemsUpdate.');
            }
            // verify required parameter 'item' is not null or undefined
            if (item === null || item === undefined) {
                throw new RequiredError('item','Required parameter item was null or undefined when calling itemsUpdate.');
            }
            const localVarPath = `/items/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication clientID required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-IBM-Client-Id")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
            }

            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof item !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(item !== undefined ? item : {}) : (item || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsApi - functional programming interface
 * @export
 */
export const ItemsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Add a new item to your stored items that you can then use in your shipment requests.
         * @summary Create Item
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {Item} item The item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemsCreate(xRMGAuthToken: string, item: Item, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemResponse>> {
            const localVarAxiosArgs = await ItemsApiAxiosParamCreator(configuration).itemsCreate(xRMGAuthToken, item, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes the specified item.
         * @summary Delete Item
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} itemId Your unique Item ID of the item to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemsDelete(xRMGAuthToken: string, itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemResponse>> {
            const localVarAxiosArgs = await ItemsApiAxiosParamCreator(configuration).itemsDelete(xRMGAuthToken, itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the item specified by your unique Item ID.
         * @summary Get Item
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} itemId Your unique Item ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemsGet(xRMGAuthToken: string, itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Item>> {
            const localVarAxiosArgs = await ItemsApiAxiosParamCreator(configuration).itemsGet(xRMGAuthToken, itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get all of your stored items
         * @summary Get Items
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemsGetAll(xRMGAuthToken: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Item>>> {
            const localVarAxiosArgs = await ItemsApiAxiosParamCreator(configuration).itemsGetAll(xRMGAuthToken, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update an item that is already stored with new details. The whole item will be replaced with new details.
         * @summary Update item
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} itemId Your unique Item ID of the item to update.
         * @param {Item} item The item with the updated details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemsUpdate(xRMGAuthToken: string, itemId: string, item: Item, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemResponse>> {
            const localVarAxiosArgs = await ItemsApiAxiosParamCreator(configuration).itemsUpdate(xRMGAuthToken, itemId, item, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ItemsApi - factory interface
 * @export
 */
export const ItemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Add a new item to your stored items that you can then use in your shipment requests.
         * @summary Create Item
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {Item} item The item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsCreate(xRMGAuthToken: string, item: Item, options?: any): AxiosPromise<ItemResponse> {
            return ItemsApiFp(configuration).itemsCreate(xRMGAuthToken, item, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the specified item.
         * @summary Delete Item
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} itemId Your unique Item ID of the item to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsDelete(xRMGAuthToken: string, itemId: string, options?: any): AxiosPromise<ItemResponse> {
            return ItemsApiFp(configuration).itemsDelete(xRMGAuthToken, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the item specified by your unique Item ID.
         * @summary Get Item
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} itemId Your unique Item ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsGet(xRMGAuthToken: string, itemId: string, options?: any): AxiosPromise<Item> {
            return ItemsApiFp(configuration).itemsGet(xRMGAuthToken, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all of your stored items
         * @summary Get Items
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsGetAll(xRMGAuthToken: string, options?: any): AxiosPromise<Array<Item>> {
            return ItemsApiFp(configuration).itemsGetAll(xRMGAuthToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an item that is already stored with new details. The whole item will be replaced with new details.
         * @summary Update item
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} itemId Your unique Item ID of the item to update.
         * @param {Item} item The item with the updated details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsUpdate(xRMGAuthToken: string, itemId: string, item: Item, options?: any): AxiosPromise<ItemResponse> {
            return ItemsApiFp(configuration).itemsUpdate(xRMGAuthToken, itemId, item, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemsApi - object-oriented interface
 * @export
 * @class ItemsApi
 * @extends {BaseAPI}
 */
export class ItemsApi extends BaseAPI {
    /**
     * Add a new item to your stored items that you can then use in your shipment requests.
     * @summary Create Item
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {Item} item The item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public itemsCreate(xRMGAuthToken: string, item: Item, options?: any) {
        return ItemsApiFp(this.configuration).itemsCreate(xRMGAuthToken, item, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the specified item.
     * @summary Delete Item
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {string} itemId Your unique Item ID of the item to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public itemsDelete(xRMGAuthToken: string, itemId: string, options?: any) {
        return ItemsApiFp(this.configuration).itemsDelete(xRMGAuthToken, itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the item specified by your unique Item ID.
     * @summary Get Item
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {string} itemId Your unique Item ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public itemsGet(xRMGAuthToken: string, itemId: string, options?: any) {
        return ItemsApiFp(this.configuration).itemsGet(xRMGAuthToken, itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all of your stored items
     * @summary Get Items
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public itemsGetAll(xRMGAuthToken: string, options?: any) {
        return ItemsApiFp(this.configuration).itemsGetAll(xRMGAuthToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an item that is already stored with new details. The whole item will be replaced with new details.
     * @summary Update item
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {string} itemId Your unique Item ID of the item to update.
     * @param {Item} item The item with the updated details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public itemsUpdate(xRMGAuthToken: string, itemId: string, item: Item, options?: any) {
        return ItemsApiFp(this.configuration).itemsUpdate(xRMGAuthToken, itemId, item, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ManifestsApi - axios parameter creator
 * @export
 */
export const ManifestsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Manifest all shipments that are ready to manifest for a single Posting Location.<br />             <br />Required to confirm parcels are ready to despatch.<br />Generates the required paperwork to despatch your parcels. <br />One or more manifests, including the base 64 encoded PDF and manifest number will be returned.<br />            <br />*Note: All average weight shipments are ignored and need to be closed out via Shipment Processing*
         * @summary Manifest All Shipments
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {ManifestRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestsCreate: async (xRMGAuthToken: string, request: ManifestRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xRMGAuthToken' is not null or undefined
            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                throw new RequiredError('xRMGAuthToken','Required parameter xRMGAuthToken was null or undefined when calling manifestsCreate.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling manifestsCreate.');
            }
            const localVarPath = `/manifests`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication clientID required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-IBM-Client-Id")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
            }

            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(request !== undefined ? request : {}) : (request || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Manifest shipments created with the given carrier codes that are ready to manifest for a single Posting Location.<br />            <br />Required to confirm parcels are ready to despatch.<br />Generates the required paperwork to despatch your parcels. <br />One or more manifests, including the base 64 encoded PDF and manifest number will be returned.<br />            <br />*Note: All average weight shipments are ignored and need to be closed out via Shipment Processing*
         * @summary Manifest by Carrier Code(s)
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {ManifestCarrierCodesRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestsCreateByCarrier: async (xRMGAuthToken: string, request: ManifestCarrierCodesRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xRMGAuthToken' is not null or undefined
            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                throw new RequiredError('xRMGAuthToken','Required parameter xRMGAuthToken was null or undefined when calling manifestsCreateByCarrier.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling manifestsCreateByCarrier.');
            }
            const localVarPath = `/manifests/bycarrier`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication clientID required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-IBM-Client-Id")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
            }

            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(request !== undefined ? request : {}) : (request || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Manifest shipments created with the given service codes that are ready to manifest for a single Posting Location.<br />            <br />Required to confirm parcels are ready to despatch.<br />Generates the required paperwork to despatch your parcels. <br />One or more manifests, including the base 64 encoded PDF and manifest number will be returned.<br />            <br />*Note: All average weight shipments are ignored and need to be closed out via Shipment Processing*
         * @summary Manifest by Service Code(s)
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {ManifestServiceCodesRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestsCreateByService: async (xRMGAuthToken: string, request: ManifestServiceCodesRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xRMGAuthToken' is not null or undefined
            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                throw new RequiredError('xRMGAuthToken','Required parameter xRMGAuthToken was null or undefined when calling manifestsCreateByService.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling manifestsCreateByService.');
            }
            const localVarPath = `/manifests/byservice`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication clientID required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-IBM-Client-Id")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
            }

            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(request !== undefined ? request : {}) : (request || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManifestsApi - functional programming interface
 * @export
 */
export const ManifestsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Manifest all shipments that are ready to manifest for a single Posting Location.<br />             <br />Required to confirm parcels are ready to despatch.<br />Generates the required paperwork to despatch your parcels. <br />One or more manifests, including the base 64 encoded PDF and manifest number will be returned.<br />            <br />*Note: All average weight shipments are ignored and need to be closed out via Shipment Processing*
         * @summary Manifest All Shipments
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {ManifestRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async manifestsCreate(xRMGAuthToken: string, request: ManifestRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManifestResponse>> {
            const localVarAxiosArgs = await ManifestsApiAxiosParamCreator(configuration).manifestsCreate(xRMGAuthToken, request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Manifest shipments created with the given carrier codes that are ready to manifest for a single Posting Location.<br />            <br />Required to confirm parcels are ready to despatch.<br />Generates the required paperwork to despatch your parcels. <br />One or more manifests, including the base 64 encoded PDF and manifest number will be returned.<br />            <br />*Note: All average weight shipments are ignored and need to be closed out via Shipment Processing*
         * @summary Manifest by Carrier Code(s)
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {ManifestCarrierCodesRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async manifestsCreateByCarrier(xRMGAuthToken: string, request: ManifestCarrierCodesRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManifestResponse>> {
            const localVarAxiosArgs = await ManifestsApiAxiosParamCreator(configuration).manifestsCreateByCarrier(xRMGAuthToken, request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Manifest shipments created with the given service codes that are ready to manifest for a single Posting Location.<br />            <br />Required to confirm parcels are ready to despatch.<br />Generates the required paperwork to despatch your parcels. <br />One or more manifests, including the base 64 encoded PDF and manifest number will be returned.<br />            <br />*Note: All average weight shipments are ignored and need to be closed out via Shipment Processing*
         * @summary Manifest by Service Code(s)
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {ManifestServiceCodesRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async manifestsCreateByService(xRMGAuthToken: string, request: ManifestServiceCodesRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManifestResponse>> {
            const localVarAxiosArgs = await ManifestsApiAxiosParamCreator(configuration).manifestsCreateByService(xRMGAuthToken, request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ManifestsApi - factory interface
 * @export
 */
export const ManifestsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Manifest all shipments that are ready to manifest for a single Posting Location.<br />             <br />Required to confirm parcels are ready to despatch.<br />Generates the required paperwork to despatch your parcels. <br />One or more manifests, including the base 64 encoded PDF and manifest number will be returned.<br />            <br />*Note: All average weight shipments are ignored and need to be closed out via Shipment Processing*
         * @summary Manifest All Shipments
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {ManifestRequest} request Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestsCreate(xRMGAuthToken: string, request: ManifestRequest, options?: any): AxiosPromise<ManifestResponse> {
            return ManifestsApiFp(configuration).manifestsCreate(xRMGAuthToken, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Manifest shipments created with the given carrier codes that are ready to manifest for a single Posting Location.<br />            <br />Required to confirm parcels are ready to despatch.<br />Generates the required paperwork to despatch your parcels. <br />One or more manifests, including the base 64 encoded PDF and manifest number will be returned.<br />            <br />*Note: All average weight shipments are ignored and need to be closed out via Shipment Processing*
         * @summary Manifest by Carrier Code(s)
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {ManifestCarrierCodesRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestsCreateByCarrier(xRMGAuthToken: string, request: ManifestCarrierCodesRequest, options?: any): AxiosPromise<ManifestResponse> {
            return ManifestsApiFp(configuration).manifestsCreateByCarrier(xRMGAuthToken, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Manifest shipments created with the given service codes that are ready to manifest for a single Posting Location.<br />            <br />Required to confirm parcels are ready to despatch.<br />Generates the required paperwork to despatch your parcels. <br />One or more manifests, including the base 64 encoded PDF and manifest number will be returned.<br />            <br />*Note: All average weight shipments are ignored and need to be closed out via Shipment Processing*
         * @summary Manifest by Service Code(s)
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {ManifestServiceCodesRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manifestsCreateByService(xRMGAuthToken: string, request: ManifestServiceCodesRequest, options?: any): AxiosPromise<ManifestResponse> {
            return ManifestsApiFp(configuration).manifestsCreateByService(xRMGAuthToken, request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManifestsApi - object-oriented interface
 * @export
 * @class ManifestsApi
 * @extends {BaseAPI}
 */
export class ManifestsApi extends BaseAPI {
    /**
     * Manifest all shipments that are ready to manifest for a single Posting Location.<br />             <br />Required to confirm parcels are ready to despatch.<br />Generates the required paperwork to despatch your parcels. <br />One or more manifests, including the base 64 encoded PDF and manifest number will be returned.<br />            <br />*Note: All average weight shipments are ignored and need to be closed out via Shipment Processing*
     * @summary Manifest All Shipments
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {ManifestRequest} request Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManifestsApi
     */
    public manifestsCreate(xRMGAuthToken: string, request: ManifestRequest, options?: any) {
        return ManifestsApiFp(this.configuration).manifestsCreate(xRMGAuthToken, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Manifest shipments created with the given carrier codes that are ready to manifest for a single Posting Location.<br />            <br />Required to confirm parcels are ready to despatch.<br />Generates the required paperwork to despatch your parcels. <br />One or more manifests, including the base 64 encoded PDF and manifest number will be returned.<br />            <br />*Note: All average weight shipments are ignored and need to be closed out via Shipment Processing*
     * @summary Manifest by Carrier Code(s)
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {ManifestCarrierCodesRequest} request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManifestsApi
     */
    public manifestsCreateByCarrier(xRMGAuthToken: string, request: ManifestCarrierCodesRequest, options?: any) {
        return ManifestsApiFp(this.configuration).manifestsCreateByCarrier(xRMGAuthToken, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Manifest shipments created with the given service codes that are ready to manifest for a single Posting Location.<br />            <br />Required to confirm parcels are ready to despatch.<br />Generates the required paperwork to despatch your parcels. <br />One or more manifests, including the base 64 encoded PDF and manifest number will be returned.<br />            <br />*Note: All average weight shipments are ignored and need to be closed out via Shipment Processing*
     * @summary Manifest by Service Code(s)
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {ManifestServiceCodesRequest} request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManifestsApi
     */
    public manifestsCreateByService(xRMGAuthToken: string, request: ManifestServiceCodesRequest, options?: any) {
        return ManifestsApiFp(this.configuration).manifestsCreateByService(xRMGAuthToken, request, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PackagingApi - axios parameter creator
 * @export
 */
export const PackagingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add new packaging to your stored packaging details that you can then use in your shipment requests.
         * @summary Create Packaging
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {Packaging} packaging The packaging details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagingCreate: async (xRMGAuthToken: string, packaging: Packaging, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xRMGAuthToken' is not null or undefined
            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                throw new RequiredError('xRMGAuthToken','Required parameter xRMGAuthToken was null or undefined when calling packagingCreate.');
            }
            // verify required parameter 'packaging' is not null or undefined
            if (packaging === null || packaging === undefined) {
                throw new RequiredError('packaging','Required parameter packaging was null or undefined when calling packagingCreate.');
            }
            const localVarPath = `/packaging`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication clientID required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-IBM-Client-Id")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
            }

            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof packaging !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(packaging !== undefined ? packaging : {}) : (packaging || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the specified packaging.
         * @summary Delete Packaging
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} packagingId Your unique Packaging ID of the packaging details to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagingDelete: async (xRMGAuthToken: string, packagingId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xRMGAuthToken' is not null or undefined
            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                throw new RequiredError('xRMGAuthToken','Required parameter xRMGAuthToken was null or undefined when calling packagingDelete.');
            }
            // verify required parameter 'packagingId' is not null or undefined
            if (packagingId === null || packagingId === undefined) {
                throw new RequiredError('packagingId','Required parameter packagingId was null or undefined when calling packagingDelete.');
            }
            const localVarPath = `/packaging/{packagingId}`
                .replace(`{${"packagingId"}}`, encodeURIComponent(String(packagingId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication clientID required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-IBM-Client-Id")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
            }

            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the packaging details specified by your unique Packaging ID.
         * @summary Get Packaging
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} packagingId Your Unique Packaging ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagingGet: async (xRMGAuthToken: string, packagingId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xRMGAuthToken' is not null or undefined
            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                throw new RequiredError('xRMGAuthToken','Required parameter xRMGAuthToken was null or undefined when calling packagingGet.');
            }
            // verify required parameter 'packagingId' is not null or undefined
            if (packagingId === null || packagingId === undefined) {
                throw new RequiredError('packagingId','Required parameter packagingId was null or undefined when calling packagingGet.');
            }
            const localVarPath = `/packaging/{packagingId}`
                .replace(`{${"packagingId"}}`, encodeURIComponent(String(packagingId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication clientID required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-IBM-Client-Id")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
            }

            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all of your stored packaging details
         * @summary Get All Packaging
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagingGetAll: async (xRMGAuthToken: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xRMGAuthToken' is not null or undefined
            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                throw new RequiredError('xRMGAuthToken','Required parameter xRMGAuthToken was null or undefined when calling packagingGetAll.');
            }
            const localVarPath = `/packaging`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication clientID required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-IBM-Client-Id")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
            }

            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update packaging details that is already stored with new details. All details will be replaced with new details.
         * @summary Update packaging
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} packagingId Your unique Packaging ID of the packaging details to update.
         * @param {Packaging} packaging The packaging with the updated details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagingUpdate: async (xRMGAuthToken: string, packagingId: string, packaging: Packaging, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xRMGAuthToken' is not null or undefined
            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                throw new RequiredError('xRMGAuthToken','Required parameter xRMGAuthToken was null or undefined when calling packagingUpdate.');
            }
            // verify required parameter 'packagingId' is not null or undefined
            if (packagingId === null || packagingId === undefined) {
                throw new RequiredError('packagingId','Required parameter packagingId was null or undefined when calling packagingUpdate.');
            }
            // verify required parameter 'packaging' is not null or undefined
            if (packaging === null || packaging === undefined) {
                throw new RequiredError('packaging','Required parameter packaging was null or undefined when calling packagingUpdate.');
            }
            const localVarPath = `/packaging/{packagingId}`
                .replace(`{${"packagingId"}}`, encodeURIComponent(String(packagingId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication clientID required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-IBM-Client-Id")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
            }

            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof packaging !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(packaging !== undefined ? packaging : {}) : (packaging || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PackagingApi - functional programming interface
 * @export
 */
export const PackagingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Add new packaging to your stored packaging details that you can then use in your shipment requests.
         * @summary Create Packaging
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {Packaging} packaging The packaging details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async packagingCreate(xRMGAuthToken: string, packaging: Packaging, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PackagingResponse>> {
            const localVarAxiosArgs = await PackagingApiAxiosParamCreator(configuration).packagingCreate(xRMGAuthToken, packaging, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes the specified packaging.
         * @summary Delete Packaging
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} packagingId Your unique Packaging ID of the packaging details to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async packagingDelete(xRMGAuthToken: string, packagingId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PackagingResponse>> {
            const localVarAxiosArgs = await PackagingApiAxiosParamCreator(configuration).packagingDelete(xRMGAuthToken, packagingId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the packaging details specified by your unique Packaging ID.
         * @summary Get Packaging
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} packagingId Your Unique Packaging ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async packagingGet(xRMGAuthToken: string, packagingId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Packaging>> {
            const localVarAxiosArgs = await PackagingApiAxiosParamCreator(configuration).packagingGet(xRMGAuthToken, packagingId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get all of your stored packaging details
         * @summary Get All Packaging
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async packagingGetAll(xRMGAuthToken: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Packaging>>> {
            const localVarAxiosArgs = await PackagingApiAxiosParamCreator(configuration).packagingGetAll(xRMGAuthToken, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update packaging details that is already stored with new details. All details will be replaced with new details.
         * @summary Update packaging
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} packagingId Your unique Packaging ID of the packaging details to update.
         * @param {Packaging} packaging The packaging with the updated details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async packagingUpdate(xRMGAuthToken: string, packagingId: string, packaging: Packaging, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PackagingResponse>> {
            const localVarAxiosArgs = await PackagingApiAxiosParamCreator(configuration).packagingUpdate(xRMGAuthToken, packagingId, packaging, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PackagingApi - factory interface
 * @export
 */
export const PackagingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Add new packaging to your stored packaging details that you can then use in your shipment requests.
         * @summary Create Packaging
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {Packaging} packaging The packaging details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagingCreate(xRMGAuthToken: string, packaging: Packaging, options?: any): AxiosPromise<PackagingResponse> {
            return PackagingApiFp(configuration).packagingCreate(xRMGAuthToken, packaging, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the specified packaging.
         * @summary Delete Packaging
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} packagingId Your unique Packaging ID of the packaging details to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagingDelete(xRMGAuthToken: string, packagingId: string, options?: any): AxiosPromise<PackagingResponse> {
            return PackagingApiFp(configuration).packagingDelete(xRMGAuthToken, packagingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the packaging details specified by your unique Packaging ID.
         * @summary Get Packaging
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} packagingId Your Unique Packaging ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagingGet(xRMGAuthToken: string, packagingId: string, options?: any): AxiosPromise<Packaging> {
            return PackagingApiFp(configuration).packagingGet(xRMGAuthToken, packagingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all of your stored packaging details
         * @summary Get All Packaging
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagingGetAll(xRMGAuthToken: string, options?: any): AxiosPromise<Array<Packaging>> {
            return PackagingApiFp(configuration).packagingGetAll(xRMGAuthToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Update packaging details that is already stored with new details. All details will be replaced with new details.
         * @summary Update packaging
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} packagingId Your unique Packaging ID of the packaging details to update.
         * @param {Packaging} packaging The packaging with the updated details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagingUpdate(xRMGAuthToken: string, packagingId: string, packaging: Packaging, options?: any): AxiosPromise<PackagingResponse> {
            return PackagingApiFp(configuration).packagingUpdate(xRMGAuthToken, packagingId, packaging, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PackagingApi - object-oriented interface
 * @export
 * @class PackagingApi
 * @extends {BaseAPI}
 */
export class PackagingApi extends BaseAPI {
    /**
     * Add new packaging to your stored packaging details that you can then use in your shipment requests.
     * @summary Create Packaging
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {Packaging} packaging The packaging details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackagingApi
     */
    public packagingCreate(xRMGAuthToken: string, packaging: Packaging, options?: any) {
        return PackagingApiFp(this.configuration).packagingCreate(xRMGAuthToken, packaging, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the specified packaging.
     * @summary Delete Packaging
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {string} packagingId Your unique Packaging ID of the packaging details to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackagingApi
     */
    public packagingDelete(xRMGAuthToken: string, packagingId: string, options?: any) {
        return PackagingApiFp(this.configuration).packagingDelete(xRMGAuthToken, packagingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the packaging details specified by your unique Packaging ID.
     * @summary Get Packaging
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {string} packagingId Your Unique Packaging ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackagingApi
     */
    public packagingGet(xRMGAuthToken: string, packagingId: string, options?: any) {
        return PackagingApiFp(this.configuration).packagingGet(xRMGAuthToken, packagingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all of your stored packaging details
     * @summary Get All Packaging
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackagingApi
     */
    public packagingGetAll(xRMGAuthToken: string, options?: any) {
        return PackagingApiFp(this.configuration).packagingGetAll(xRMGAuthToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update packaging details that is already stored with new details. All details will be replaced with new details.
     * @summary Update packaging
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {string} packagingId Your unique Packaging ID of the packaging details to update.
     * @param {Packaging} packaging The packaging with the updated details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackagingApi
     */
    public packagingUpdate(xRMGAuthToken: string, packagingId: string, packaging: Packaging, options?: any) {
        return PackagingApiFp(this.configuration).packagingUpdate(xRMGAuthToken, packagingId, packaging, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ShipmentsApi - axios parameter creator
 * @export
 */
export const ShipmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Can be used to cancel/void one or more current shipping labels.<br />This service can only be used before the shipment has been confirmed either by calling the manifest create request or by closing out via the User Interface.<br />There can be a maximum of 99 cancellation requests per call.
         * @summary Cancel Shipments
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {Array<ShipmentCancelRequest>} shipmentCancelRequests Shipment Cancel Requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipmentsCancel: async (xRMGAuthToken: string, shipmentCancelRequests: Array<ShipmentCancelRequest>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xRMGAuthToken' is not null or undefined
            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                throw new RequiredError('xRMGAuthToken','Required parameter xRMGAuthToken was null or undefined when calling shipmentsCancel.');
            }
            // verify required parameter 'shipmentCancelRequests' is not null or undefined
            if (shipmentCancelRequests === null || shipmentCancelRequests === undefined) {
                throw new RequiredError('shipmentCancelRequests','Required parameter shipmentCancelRequests was null or undefined when calling shipmentsCancel.');
            }
            const localVarPath = `/shipments/cancel`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication clientID required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-IBM-Client-Id")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
            }

            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof shipmentCancelRequests !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(shipmentCancelRequests !== undefined ? shipmentCancelRequests : {}) : (shipmentCancelRequests || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use to generate the final delivery label for your packages.<br />            <br />The request is split into several sections:<br />            <br />**Shipper** - who and where the parcel is coming from - optional if the posting location is to be used.<br />**Destination** - who and where the parcel is going to.<br />**Shipment Information** - overall package details, individual item details and requested service information.
         * @summary Create Shipment
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {CreateShipmentShipment} shipment The shipment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipmentsCreate: async (xRMGAuthToken: string, shipment: CreateShipmentShipment, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xRMGAuthToken' is not null or undefined
            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                throw new RequiredError('xRMGAuthToken','Required parameter xRMGAuthToken was null or undefined when calling shipmentsCreate.');
            }
            // verify required parameter 'shipment' is not null or undefined
            if (shipment === null || shipment === undefined) {
                throw new RequiredError('shipment','Required parameter shipment was null or undefined when calling shipmentsCreate.');
            }
            const localVarPath = `/shipments`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication clientID required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-IBM-Client-Id")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
            }

            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof shipment !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(shipment !== undefined ? shipment : {}) : (shipment || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to update the shipment shipping date for a current shipment.<br />A shipment can be deferred by a maximum of 28 days from the date of the request.<br />This service can only be used before the shipment has been confirmed either by calling the manifest create request or by closing out via the User Interface.<br />There can be a maximum of 99 defer requests per call.
         * @summary Defer Shipments
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {Array<ShipmentDeferRequest>} shipmentDeferRequests The shipments to defer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipmentsDefer: async (xRMGAuthToken: string, shipmentDeferRequests: Array<ShipmentDeferRequest>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xRMGAuthToken' is not null or undefined
            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                throw new RequiredError('xRMGAuthToken','Required parameter xRMGAuthToken was null or undefined when calling shipmentsDefer.');
            }
            // verify required parameter 'shipmentDeferRequests' is not null or undefined
            if (shipmentDeferRequests === null || shipmentDeferRequests === undefined) {
                throw new RequiredError('shipmentDeferRequests','Required parameter shipmentDeferRequests was null or undefined when calling shipmentsDefer.');
            }
            const localVarPath = `/shipments/defer`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication clientID required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-IBM-Client-Id")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
            }

            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof shipmentDeferRequests !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(shipmentDeferRequests !== undefined ? shipmentDeferRequests : {}) : (shipmentDeferRequests || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to put a shipment on hold indefinitely.<br />A shipment on hold will not be included in any closeouts, but instead will remain in its current state.<br />Calling printLabel will release the shipment from being held.<br />This service can only be used before the shipment has been confirmed either by calling the manifest create request or by closing out via the User Interface.<br />            <br />A hold reason must be provided and must match those set in Pro Shipping under your maintenance screens.<br />If no hold reasons exist, then shipments cannot be put on hold.<br />            <br />There can be a maximum of 99 hold requests per call.
         * @summary Hold Shipments
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {Array<ShipmentHoldRequest>} shipmentHoldRequests The shipments to hold.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipmentsHold: async (xRMGAuthToken: string, shipmentHoldRequests: Array<ShipmentHoldRequest>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xRMGAuthToken' is not null or undefined
            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                throw new RequiredError('xRMGAuthToken','Required parameter xRMGAuthToken was null or undefined when calling shipmentsHold.');
            }
            // verify required parameter 'shipmentHoldRequests' is not null or undefined
            if (shipmentHoldRequests === null || shipmentHoldRequests === undefined) {
                throw new RequiredError('shipmentHoldRequests','Required parameter shipmentHoldRequests was null or undefined when calling shipmentsHold.');
            }
            const localVarPath = `/shipments/hold`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication clientID required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-IBM-Client-Id")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
            }

            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof shipmentHoldRequests !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(shipmentHoldRequests !== undefined ? shipmentHoldRequests : {}) : (shipmentHoldRequests || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Prints the requested document for the shipment.<br />If item information, description of goods or reason for export have not been provided then the document cannot be printed.<br />            <br />This service can only be used before the shipment has been confirmed either by calling the manifest create request or by closing out via the User Interface.
         * @summary Print Document
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} shipmentId Shipment Id&lt;br /&gt;The tracking number or Unique Id of the shipment to print.
         * @param {PrintDocumentRequest} printDocumentRequest Print Document Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipmentsPrintDocument: async (xRMGAuthToken: string, shipmentId: string, printDocumentRequest: PrintDocumentRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xRMGAuthToken' is not null or undefined
            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                throw new RequiredError('xRMGAuthToken','Required parameter xRMGAuthToken was null or undefined when calling shipmentsPrintDocument.');
            }
            // verify required parameter 'shipmentId' is not null or undefined
            if (shipmentId === null || shipmentId === undefined) {
                throw new RequiredError('shipmentId','Required parameter shipmentId was null or undefined when calling shipmentsPrintDocument.');
            }
            // verify required parameter 'printDocumentRequest' is not null or undefined
            if (printDocumentRequest === null || printDocumentRequest === undefined) {
                throw new RequiredError('printDocumentRequest','Required parameter printDocumentRequest was null or undefined when calling shipmentsPrintDocument.');
            }
            const localVarPath = `/shipments/{shipmentId}/printDocument`
                .replace(`{${"shipmentId"}}`, encodeURIComponent(String(shipmentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication clientID required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-IBM-Client-Id")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
            }

            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof printDocumentRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(printDocumentRequest !== undefined ? printDocumentRequest : {}) : (printDocumentRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Prints the label for the shipment.<br />Moves the shipment to processed, ready to manifest, if the shipment was not already in a processed state.<br />This service can only be used before the shipment has been confirmed either by calling the manifest create request or by closing out via the User Interface.<br />**On Hold Shipment**<br />Calling print label on a held shipment will release the shipment from hold and update the shipment date to today.
         * @summary Print Label
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} shipmentId Shipment Id&lt;br /&gt;The tracking number or Unique Id of the shipment to print.
         * @param {PrintLabelRequest} printLabelRequest Print Label Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipmentsPrintLabel: async (xRMGAuthToken: string, shipmentId: string, printLabelRequest: PrintLabelRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xRMGAuthToken' is not null or undefined
            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                throw new RequiredError('xRMGAuthToken','Required parameter xRMGAuthToken was null or undefined when calling shipmentsPrintLabel.');
            }
            // verify required parameter 'shipmentId' is not null or undefined
            if (shipmentId === null || shipmentId === undefined) {
                throw new RequiredError('shipmentId','Required parameter shipmentId was null or undefined when calling shipmentsPrintLabel.');
            }
            // verify required parameter 'printLabelRequest' is not null or undefined
            if (printLabelRequest === null || printLabelRequest === undefined) {
                throw new RequiredError('printLabelRequest','Required parameter printLabelRequest was null or undefined when calling shipmentsPrintLabel.');
            }
            const localVarPath = `/shipments/{shipmentId}/printLabel`
                .replace(`{${"shipmentId"}}`, encodeURIComponent(String(shipmentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication clientID required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-IBM-Client-Id")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
            }

            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof printLabelRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(printLabelRequest !== undefined ? printLabelRequest : {}) : (printLabelRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to release a shipment from being on hold.<br />This service can only be used for shipments on hold.<br />            <br />Releasing a shipment from hold will update the shipment date to today\'s date and if the shipment is processed it will be included the next requested manifest.<br />            <br />There can be a maximum of 99 release requests per call.
         * @summary Release Shipments
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {ShipmentsReleaseRequest} shipmentsReleaseRequest Shipments Release Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipmentsRelease: async (xRMGAuthToken: string, shipmentsReleaseRequest: ShipmentsReleaseRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xRMGAuthToken' is not null or undefined
            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                throw new RequiredError('xRMGAuthToken','Required parameter xRMGAuthToken was null or undefined when calling shipmentsRelease.');
            }
            // verify required parameter 'shipmentsReleaseRequest' is not null or undefined
            if (shipmentsReleaseRequest === null || shipmentsReleaseRequest === undefined) {
                throw new RequiredError('shipmentsReleaseRequest','Required parameter shipmentsReleaseRequest was null or undefined when calling shipmentsRelease.');
            }
            const localVarPath = `/shipments/release`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication clientID required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-IBM-Client-Id")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
            }

            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof shipmentsReleaseRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(shipmentsReleaseRequest !== undefined ? shipmentsReleaseRequest : {}) : (shipmentsReleaseRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of available services for a potential shipment.<br />            <br />**Destination** - where the parcel is going to.<br />**Shipment Information** - overall package details and requested service requirements.
         * @summary Service Availability
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {ServiceAvailabilityShipment} shipment The shipment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipmentsServiceAvailability: async (xRMGAuthToken: string, shipment: ServiceAvailabilityShipment, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xRMGAuthToken' is not null or undefined
            if (xRMGAuthToken === null || xRMGAuthToken === undefined) {
                throw new RequiredError('xRMGAuthToken','Required parameter xRMGAuthToken was null or undefined when calling shipmentsServiceAvailability.');
            }
            // verify required parameter 'shipment' is not null or undefined
            if (shipment === null || shipment === undefined) {
                throw new RequiredError('shipment','Required parameter shipment was null or undefined when calling shipmentsServiceAvailability.');
            }
            const localVarPath = `/shipments/serviceAvailability`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication clientID required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-IBM-Client-Id")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
            }

            if (xRMGAuthToken !== undefined && xRMGAuthToken !== null) {
                localVarHeaderParameter['X-RMG-Auth-Token'] = String(xRMGAuthToken);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof shipment !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(shipment !== undefined ? shipment : {}) : (shipment || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShipmentsApi - functional programming interface
 * @export
 */
export const ShipmentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Can be used to cancel/void one or more current shipping labels.<br />This service can only be used before the shipment has been confirmed either by calling the manifest create request or by closing out via the User Interface.<br />There can be a maximum of 99 cancellation requests per call.
         * @summary Cancel Shipments
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {Array<ShipmentCancelRequest>} shipmentCancelRequests Shipment Cancel Requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shipmentsCancel(xRMGAuthToken: string, shipmentCancelRequests: Array<ShipmentCancelRequest>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShipmentsCancelResponse>> {
            const localVarAxiosArgs = await ShipmentsApiAxiosParamCreator(configuration).shipmentsCancel(xRMGAuthToken, shipmentCancelRequests, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use to generate the final delivery label for your packages.<br />            <br />The request is split into several sections:<br />            <br />**Shipper** - who and where the parcel is coming from - optional if the posting location is to be used.<br />**Destination** - who and where the parcel is going to.<br />**Shipment Information** - overall package details, individual item details and requested service information.
         * @summary Create Shipment
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {CreateShipmentShipment} shipment The shipment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shipmentsCreate(xRMGAuthToken: string, shipment: CreateShipmentShipment, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShipmentCreateResponse>> {
            const localVarAxiosArgs = await ShipmentsApiAxiosParamCreator(configuration).shipmentsCreate(xRMGAuthToken, shipment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Used to update the shipment shipping date for a current shipment.<br />A shipment can be deferred by a maximum of 28 days from the date of the request.<br />This service can only be used before the shipment has been confirmed either by calling the manifest create request or by closing out via the User Interface.<br />There can be a maximum of 99 defer requests per call.
         * @summary Defer Shipments
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {Array<ShipmentDeferRequest>} shipmentDeferRequests The shipments to defer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shipmentsDefer(xRMGAuthToken: string, shipmentDeferRequests: Array<ShipmentDeferRequest>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShipmentsDeferResponse>> {
            const localVarAxiosArgs = await ShipmentsApiAxiosParamCreator(configuration).shipmentsDefer(xRMGAuthToken, shipmentDeferRequests, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Used to put a shipment on hold indefinitely.<br />A shipment on hold will not be included in any closeouts, but instead will remain in its current state.<br />Calling printLabel will release the shipment from being held.<br />This service can only be used before the shipment has been confirmed either by calling the manifest create request or by closing out via the User Interface.<br />            <br />A hold reason must be provided and must match those set in Pro Shipping under your maintenance screens.<br />If no hold reasons exist, then shipments cannot be put on hold.<br />            <br />There can be a maximum of 99 hold requests per call.
         * @summary Hold Shipments
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {Array<ShipmentHoldRequest>} shipmentHoldRequests The shipments to hold.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shipmentsHold(xRMGAuthToken: string, shipmentHoldRequests: Array<ShipmentHoldRequest>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShipmentsHoldResponse>> {
            const localVarAxiosArgs = await ShipmentsApiAxiosParamCreator(configuration).shipmentsHold(xRMGAuthToken, shipmentHoldRequests, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Prints the requested document for the shipment.<br />If item information, description of goods or reason for export have not been provided then the document cannot be printed.<br />            <br />This service can only be used before the shipment has been confirmed either by calling the manifest create request or by closing out via the User Interface.
         * @summary Print Document
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} shipmentId Shipment Id&lt;br /&gt;The tracking number or Unique Id of the shipment to print.
         * @param {PrintDocumentRequest} printDocumentRequest Print Document Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shipmentsPrintDocument(xRMGAuthToken: string, shipmentId: string, printDocumentRequest: PrintDocumentRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrintDocumentResponse>> {
            const localVarAxiosArgs = await ShipmentsApiAxiosParamCreator(configuration).shipmentsPrintDocument(xRMGAuthToken, shipmentId, printDocumentRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Prints the label for the shipment.<br />Moves the shipment to processed, ready to manifest, if the shipment was not already in a processed state.<br />This service can only be used before the shipment has been confirmed either by calling the manifest create request or by closing out via the User Interface.<br />**On Hold Shipment**<br />Calling print label on a held shipment will release the shipment from hold and update the shipment date to today.
         * @summary Print Label
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} shipmentId Shipment Id&lt;br /&gt;The tracking number or Unique Id of the shipment to print.
         * @param {PrintLabelRequest} printLabelRequest Print Label Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shipmentsPrintLabel(xRMGAuthToken: string, shipmentId: string, printLabelRequest: PrintLabelRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrintLabelResponse>> {
            const localVarAxiosArgs = await ShipmentsApiAxiosParamCreator(configuration).shipmentsPrintLabel(xRMGAuthToken, shipmentId, printLabelRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Used to release a shipment from being on hold.<br />This service can only be used for shipments on hold.<br />            <br />Releasing a shipment from hold will update the shipment date to today\'s date and if the shipment is processed it will be included the next requested manifest.<br />            <br />There can be a maximum of 99 release requests per call.
         * @summary Release Shipments
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {ShipmentsReleaseRequest} shipmentsReleaseRequest Shipments Release Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shipmentsRelease(xRMGAuthToken: string, shipmentsReleaseRequest: ShipmentsReleaseRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShipmentsReleaseResponse>> {
            const localVarAxiosArgs = await ShipmentsApiAxiosParamCreator(configuration).shipmentsRelease(xRMGAuthToken, shipmentsReleaseRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a list of available services for a potential shipment.<br />            <br />**Destination** - where the parcel is going to.<br />**Shipment Information** - overall package details and requested service requirements.
         * @summary Service Availability
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {ServiceAvailabilityShipment} shipment The shipment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shipmentsServiceAvailability(xRMGAuthToken: string, shipment: ServiceAvailabilityShipment, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceAvailabilityResponse>> {
            const localVarAxiosArgs = await ShipmentsApiAxiosParamCreator(configuration).shipmentsServiceAvailability(xRMGAuthToken, shipment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ShipmentsApi - factory interface
 * @export
 */
export const ShipmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Can be used to cancel/void one or more current shipping labels.<br />This service can only be used before the shipment has been confirmed either by calling the manifest create request or by closing out via the User Interface.<br />There can be a maximum of 99 cancellation requests per call.
         * @summary Cancel Shipments
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {Array<ShipmentCancelRequest>} shipmentCancelRequests Shipment Cancel Requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipmentsCancel(xRMGAuthToken: string, shipmentCancelRequests: Array<ShipmentCancelRequest>, options?: any): AxiosPromise<ShipmentsCancelResponse> {
            return ShipmentsApiFp(configuration).shipmentsCancel(xRMGAuthToken, shipmentCancelRequests, options).then((request) => request(axios, basePath));
        },
        /**
         * Use to generate the final delivery label for your packages.<br />            <br />The request is split into several sections:<br />            <br />**Shipper** - who and where the parcel is coming from - optional if the posting location is to be used.<br />**Destination** - who and where the parcel is going to.<br />**Shipment Information** - overall package details, individual item details and requested service information.
         * @summary Create Shipment
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {CreateShipmentShipment} shipment The shipment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipmentsCreate(xRMGAuthToken: string, shipment: CreateShipmentShipment, options?: any): AxiosPromise<ShipmentCreateResponse> {
            return ShipmentsApiFp(configuration).shipmentsCreate(xRMGAuthToken, shipment, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to update the shipment shipping date for a current shipment.<br />A shipment can be deferred by a maximum of 28 days from the date of the request.<br />This service can only be used before the shipment has been confirmed either by calling the manifest create request or by closing out via the User Interface.<br />There can be a maximum of 99 defer requests per call.
         * @summary Defer Shipments
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {Array<ShipmentDeferRequest>} shipmentDeferRequests The shipments to defer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipmentsDefer(xRMGAuthToken: string, shipmentDeferRequests: Array<ShipmentDeferRequest>, options?: any): AxiosPromise<ShipmentsDeferResponse> {
            return ShipmentsApiFp(configuration).shipmentsDefer(xRMGAuthToken, shipmentDeferRequests, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to put a shipment on hold indefinitely.<br />A shipment on hold will not be included in any closeouts, but instead will remain in its current state.<br />Calling printLabel will release the shipment from being held.<br />This service can only be used before the shipment has been confirmed either by calling the manifest create request or by closing out via the User Interface.<br />            <br />A hold reason must be provided and must match those set in Pro Shipping under your maintenance screens.<br />If no hold reasons exist, then shipments cannot be put on hold.<br />            <br />There can be a maximum of 99 hold requests per call.
         * @summary Hold Shipments
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {Array<ShipmentHoldRequest>} shipmentHoldRequests The shipments to hold.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipmentsHold(xRMGAuthToken: string, shipmentHoldRequests: Array<ShipmentHoldRequest>, options?: any): AxiosPromise<ShipmentsHoldResponse> {
            return ShipmentsApiFp(configuration).shipmentsHold(xRMGAuthToken, shipmentHoldRequests, options).then((request) => request(axios, basePath));
        },
        /**
         * Prints the requested document for the shipment.<br />If item information, description of goods or reason for export have not been provided then the document cannot be printed.<br />            <br />This service can only be used before the shipment has been confirmed either by calling the manifest create request or by closing out via the User Interface.
         * @summary Print Document
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} shipmentId Shipment Id&lt;br /&gt;The tracking number or Unique Id of the shipment to print.
         * @param {PrintDocumentRequest} printDocumentRequest Print Document Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipmentsPrintDocument(xRMGAuthToken: string, shipmentId: string, printDocumentRequest: PrintDocumentRequest, options?: any): AxiosPromise<PrintDocumentResponse> {
            return ShipmentsApiFp(configuration).shipmentsPrintDocument(xRMGAuthToken, shipmentId, printDocumentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Prints the label for the shipment.<br />Moves the shipment to processed, ready to manifest, if the shipment was not already in a processed state.<br />This service can only be used before the shipment has been confirmed either by calling the manifest create request or by closing out via the User Interface.<br />**On Hold Shipment**<br />Calling print label on a held shipment will release the shipment from hold and update the shipment date to today.
         * @summary Print Label
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {string} shipmentId Shipment Id&lt;br /&gt;The tracking number or Unique Id of the shipment to print.
         * @param {PrintLabelRequest} printLabelRequest Print Label Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipmentsPrintLabel(xRMGAuthToken: string, shipmentId: string, printLabelRequest: PrintLabelRequest, options?: any): AxiosPromise<PrintLabelResponse> {
            return ShipmentsApiFp(configuration).shipmentsPrintLabel(xRMGAuthToken, shipmentId, printLabelRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to release a shipment from being on hold.<br />This service can only be used for shipments on hold.<br />            <br />Releasing a shipment from hold will update the shipment date to today\'s date and if the shipment is processed it will be included the next requested manifest.<br />            <br />There can be a maximum of 99 release requests per call.
         * @summary Release Shipments
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {ShipmentsReleaseRequest} shipmentsReleaseRequest Shipments Release Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipmentsRelease(xRMGAuthToken: string, shipmentsReleaseRequest: ShipmentsReleaseRequest, options?: any): AxiosPromise<ShipmentsReleaseResponse> {
            return ShipmentsApiFp(configuration).shipmentsRelease(xRMGAuthToken, shipmentsReleaseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of available services for a potential shipment.<br />            <br />**Destination** - where the parcel is going to.<br />**Shipment Information** - overall package details and requested service requirements.
         * @summary Service Availability
         * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
         * @param {ServiceAvailabilityShipment} shipment The shipment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipmentsServiceAvailability(xRMGAuthToken: string, shipment: ServiceAvailabilityShipment, options?: any): AxiosPromise<ServiceAvailabilityResponse> {
            return ShipmentsApiFp(configuration).shipmentsServiceAvailability(xRMGAuthToken, shipment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ShipmentsApi - object-oriented interface
 * @export
 * @class ShipmentsApi
 * @extends {BaseAPI}
 */
export class ShipmentsApi extends BaseAPI {
    /**
     * Can be used to cancel/void one or more current shipping labels.<br />This service can only be used before the shipment has been confirmed either by calling the manifest create request or by closing out via the User Interface.<br />There can be a maximum of 99 cancellation requests per call.
     * @summary Cancel Shipments
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {Array<ShipmentCancelRequest>} shipmentCancelRequests Shipment Cancel Requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    public shipmentsCancel(xRMGAuthToken: string, shipmentCancelRequests: Array<ShipmentCancelRequest>, options?: any) {
        return ShipmentsApiFp(this.configuration).shipmentsCancel(xRMGAuthToken, shipmentCancelRequests, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use to generate the final delivery label for your packages.<br />            <br />The request is split into several sections:<br />            <br />**Shipper** - who and where the parcel is coming from - optional if the posting location is to be used.<br />**Destination** - who and where the parcel is going to.<br />**Shipment Information** - overall package details, individual item details and requested service information.
     * @summary Create Shipment
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {CreateShipmentShipment} shipment The shipment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    public shipmentsCreate(xRMGAuthToken: string, shipment: CreateShipmentShipment, options?: any) {
        return ShipmentsApiFp(this.configuration).shipmentsCreate(xRMGAuthToken, shipment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to update the shipment shipping date for a current shipment.<br />A shipment can be deferred by a maximum of 28 days from the date of the request.<br />This service can only be used before the shipment has been confirmed either by calling the manifest create request or by closing out via the User Interface.<br />There can be a maximum of 99 defer requests per call.
     * @summary Defer Shipments
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {Array<ShipmentDeferRequest>} shipmentDeferRequests The shipments to defer.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    public shipmentsDefer(xRMGAuthToken: string, shipmentDeferRequests: Array<ShipmentDeferRequest>, options?: any) {
        return ShipmentsApiFp(this.configuration).shipmentsDefer(xRMGAuthToken, shipmentDeferRequests, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to put a shipment on hold indefinitely.<br />A shipment on hold will not be included in any closeouts, but instead will remain in its current state.<br />Calling printLabel will release the shipment from being held.<br />This service can only be used before the shipment has been confirmed either by calling the manifest create request or by closing out via the User Interface.<br />            <br />A hold reason must be provided and must match those set in Pro Shipping under your maintenance screens.<br />If no hold reasons exist, then shipments cannot be put on hold.<br />            <br />There can be a maximum of 99 hold requests per call.
     * @summary Hold Shipments
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {Array<ShipmentHoldRequest>} shipmentHoldRequests The shipments to hold.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    public shipmentsHold(xRMGAuthToken: string, shipmentHoldRequests: Array<ShipmentHoldRequest>, options?: any) {
        return ShipmentsApiFp(this.configuration).shipmentsHold(xRMGAuthToken, shipmentHoldRequests, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Prints the requested document for the shipment.<br />If item information, description of goods or reason for export have not been provided then the document cannot be printed.<br />            <br />This service can only be used before the shipment has been confirmed either by calling the manifest create request or by closing out via the User Interface.
     * @summary Print Document
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {string} shipmentId Shipment Id&lt;br /&gt;The tracking number or Unique Id of the shipment to print.
     * @param {PrintDocumentRequest} printDocumentRequest Print Document Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    public shipmentsPrintDocument(xRMGAuthToken: string, shipmentId: string, printDocumentRequest: PrintDocumentRequest, options?: any) {
        return ShipmentsApiFp(this.configuration).shipmentsPrintDocument(xRMGAuthToken, shipmentId, printDocumentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Prints the label for the shipment.<br />Moves the shipment to processed, ready to manifest, if the shipment was not already in a processed state.<br />This service can only be used before the shipment has been confirmed either by calling the manifest create request or by closing out via the User Interface.<br />**On Hold Shipment**<br />Calling print label on a held shipment will release the shipment from hold and update the shipment date to today.
     * @summary Print Label
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {string} shipmentId Shipment Id&lt;br /&gt;The tracking number or Unique Id of the shipment to print.
     * @param {PrintLabelRequest} printLabelRequest Print Label Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    public shipmentsPrintLabel(xRMGAuthToken: string, shipmentId: string, printLabelRequest: PrintLabelRequest, options?: any) {
        return ShipmentsApiFp(this.configuration).shipmentsPrintLabel(xRMGAuthToken, shipmentId, printLabelRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to release a shipment from being on hold.<br />This service can only be used for shipments on hold.<br />            <br />Releasing a shipment from hold will update the shipment date to today\'s date and if the shipment is processed it will be included the next requested manifest.<br />            <br />There can be a maximum of 99 release requests per call.
     * @summary Release Shipments
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {ShipmentsReleaseRequest} shipmentsReleaseRequest Shipments Release Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    public shipmentsRelease(xRMGAuthToken: string, shipmentsReleaseRequest: ShipmentsReleaseRequest, options?: any) {
        return ShipmentsApiFp(this.configuration).shipmentsRelease(xRMGAuthToken, shipmentsReleaseRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of available services for a potential shipment.<br />            <br />**Destination** - where the parcel is going to.<br />**Shipment Information** - overall package details and requested service requirements.
     * @summary Service Availability
     * @param {string} xRMGAuthToken Authorisation token required to invoke this operation. Can be retrieved by invoking the **_/token** operation.
     * @param {ServiceAvailabilityShipment} shipment The shipment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    public shipmentsServiceAvailability(xRMGAuthToken: string, shipment: ServiceAvailabilityShipment, options?: any) {
        return ShipmentsApiFp(this.configuration).shipmentsServiceAvailability(xRMGAuthToken, shipment, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TokenApi - axios parameter creator
 * @export
 */
export const TokenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Provides security token.
         * @summary Authenticates a User and provides token.
         * @param {string} xRMGSecurityUsername User Name
         * @param {string} xRMGSecurityPassword Password in plain text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticatePost: async (xRMGSecurityUsername: string, xRMGSecurityPassword: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xRMGSecurityUsername' is not null or undefined
            if (xRMGSecurityUsername === null || xRMGSecurityUsername === undefined) {
                throw new RequiredError('xRMGSecurityUsername','Required parameter xRMGSecurityUsername was null or undefined when calling authenticatePost.');
            }
            // verify required parameter 'xRMGSecurityPassword' is not null or undefined
            if (xRMGSecurityPassword === null || xRMGSecurityPassword === undefined) {
                throw new RequiredError('xRMGSecurityPassword','Required parameter xRMGSecurityPassword was null or undefined when calling authenticatePost.');
            }
            const localVarPath = `/token`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication clientID required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-IBM-Client-Id")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-IBM-Client-Id"] = localVarApiKeyValue;
            }

            // authentication clientSecret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-IBM-Client-Secret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-IBM-Client-Secret"] = localVarApiKeyValue;
            }

            if (xRMGSecurityUsername !== undefined && xRMGSecurityUsername !== null) {
                localVarHeaderParameter['X-RMG-Security-Username'] = String(xRMGSecurityUsername);
            }

            if (xRMGSecurityPassword !== undefined && xRMGSecurityPassword !== null) {
                localVarHeaderParameter['X-RMG-Security-Password'] = String(xRMGSecurityPassword);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TokenApi - functional programming interface
 * @export
 */
export const TokenApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Provides security token.
         * @summary Authenticates a User and provides token.
         * @param {string} xRMGSecurityUsername User Name
         * @param {string} xRMGSecurityPassword Password in plain text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticatePost(xRMGSecurityUsername: string, xRMGSecurityPassword: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await TokenApiAxiosParamCreator(configuration).authenticatePost(xRMGSecurityUsername, xRMGSecurityPassword, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TokenApi - factory interface
 * @export
 */
export const TokenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Provides security token.
         * @summary Authenticates a User and provides token.
         * @param {string} xRMGSecurityUsername User Name
         * @param {string} xRMGSecurityPassword Password in plain text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticatePost(xRMGSecurityUsername: string, xRMGSecurityPassword: string, options?: any): AxiosPromise<void> {
            return TokenApiFp(configuration).authenticatePost(xRMGSecurityUsername, xRMGSecurityPassword, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TokenApi - object-oriented interface
 * @export
 * @class TokenApi
 * @extends {BaseAPI}
 */
export class TokenApi extends BaseAPI {
    /**
     * Provides security token.
     * @summary Authenticates a User and provides token.
     * @param {string} xRMGSecurityUsername User Name
     * @param {string} xRMGSecurityPassword Password in plain text
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenApi
     */
    public authenticatePost(xRMGSecurityUsername: string, xRMGSecurityPassword: string, options?: any) {
        return TokenApiFp(this.configuration).authenticatePost(xRMGSecurityUsername, xRMGSecurityPassword, options).then((request) => request(this.axios, this.basePath));
    }
}


